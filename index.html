<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Organigram with Import</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding-top: 80px;
            /* Space for fixed toolbar only */
            margin: 0;
        }

        .toolbar {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 99;
            border-bottom: 1px solid #e9ecef;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            margin: 0;
        }

        .toolbar-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            justify-content: flex-start;
        }

        .toolbar-section:last-child {
            margin-bottom: 0;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid #cccccc;
            border-radius: 4px;
            background: #ffffff;
            color: #333333;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #f5f5f5;
            border-color: #999999;
        }

        .btn:disabled {
            background: #f8f8f8;
            color: #cccccc;
            cursor: not-allowed;
            border-color: #e0e0e0;
        }

        .btn.primary {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .btn.primary:hover {
            background: #0056b3;
            border-color: #004085;
        }

        .search-input {
            padding: 10px 15px;
            border: 1px solid #cccccc;
            border-radius: 4px;
            font-size: 14px;
            width: 350px;
            transition: all 0.3s;
        }

        .search-input:focus {
            outline: none;
            border-color: #999999;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
        }

        .import-section {
            background: white;
            margin: 20px;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 3px dashed #ff8c42;
            text-align: center;
            transition: all 0.3s;
        }

        .import-section.dragover {
            border-color: #ff6b35;
            background: #fff8f5;
            transform: scale(1.02);
            box-shadow: 0 4px 20px rgba(255, 107, 53, 0.2);
        }

        .import-section.dragover .file-drop-icon {
            transform: scale(1.2);
            animation: bounce 0.6s infinite alternate;
        }

        @keyframes bounce {
            0% { transform: scale(1.2) translateY(0px); }
            100% { transform: scale(1.2) translateY(-5px); }
        }

        .hidden {
            display: none !important;
        }

        .import-section.hidden {
            display: none;
        }

        .import-section.minimized {
            padding: 10px 20px;
            margin: 10px 20px;
            border: 1px solid #e0e0e0;
            border-style: solid;
        }

        .import-section.minimized .file-drop-area {
            padding: 20px;
        }

        .file-input {
            display: none;
        }

        .file-drop-area {
            padding: 60px;
            cursor: pointer;
            position: relative;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .file-drop-area:hover {
            background: #fff8f5;
        }

        .file-drop-icon {
            font-size: 48px;
            color: #ff8c42;
            margin-bottom: 15px;
            display: block;
            transition: all 0.3s ease;
        }

        .file-drop-area:hover .file-drop-icon {
            transform: scale(1.1);
            color: #ff6b35;
        }

        .import-progress {
            margin: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: #007bff;
            width: 0%;
            transition: width 0.3s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            text-align: center;
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            color: #333333;
            margin-bottom: 10px;
        }

        .tree-container {
            background: white;
            margin: 20px;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.08);
            min-height: 70vh;
        }

        .tree {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            font-size: 13px;
        }

        .node {
            margin: 1px 0;
            position: relative;
        }

        .node-content {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.3s ease;
            cursor: pointer;
            border: 2px solid transparent;
            min-width: 0;
            /* Allow flex items to shrink */
        }

        .node-content:hover {
            background-color: #f5f5f5;
            transform: translateX(2px);
            border-color: #cccccc;
        }

        .node-content.highlighted {
            background: #fff3e0 !important;
            border: 3px solid #ff6b35 !important;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.3) !important;
            transform: scale(1.02);
            transition: all 0.3s ease;
        }

        .toggle-btn {
            width: 20px;
            height: 20px;
            border: 1px solid #cccccc;
            background: #ffffff;
            color: #333333;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            font-weight: bold;
        }

        .toggle-btn:hover {
            background: #f5f5f5;
            border-color: #999999;
        }

        .toggle-btn.no-children {
            background: #f8f8f8;
            color: #cccccc;
            cursor: default;
            border-color: #e0e0e0;
        }

        .node-label {
            flex: 1;
            font-weight: 500;
            margin-right: 8px;
            font-size: 13px;
            line-height: 1.3;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .node-label-main {
            font-weight: 500;
            font-size: 13px;
        }

        .node-label-separator {
            color: #999;
            font-weight: normal;
            font-size: 12px;
        }

        .node-label-german {
            font-size: 12px;
            color: #666;
            font-weight: 400;
            font-style: italic;
        }

        .german-indicator {
            color: #6c757d;
            font-size: 9px;
            margin-left: 2px;
            padding: 1px 3px;
            background: #f8f9fa;
            border-radius: 2px;
            border: 1px solid #dee2e6;
        }

        .node-label.editable {
            cursor: text;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .node-label.editable:hover {
            background-color: #f0f0f0;
        }

        .node-label input {
            border: none;
            background: transparent;
            font: inherit;
            color: inherit;
            width: 100%;
            outline: none;
        }

        .edit-indicator {
            display: none;
            color: #999;
            font-size: 10px;
            margin-left: 4px;
        }

        .merge-indicator {
            display: none;
            color: #ff6b35;
            background: rgba(255, 107, 53, 0.1);
            font-size: 14px;
            margin-left: 6px;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
            animation: mergeFlash 2s ease-in-out infinite;
            text-shadow: 0 0 3px rgba(255, 107, 53, 0.5);
            border: 1px solid rgba(255, 107, 53, 0.3);
        }

        @keyframes mergeFlash {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
                background: rgba(255, 107, 53, 0.1);
            }

            50% {
                opacity: 0.8;
                transform: scale(1.05);
                background: rgba(255, 107, 53, 0.2);
            }
        }

        .node-merged .merge-indicator {
            display: inline;
        }

        .edit-mode .edit-indicator {
            display: inline;
        }

        .edit-mode .node-label.editable {
            background-color: #f8f8f8;
            border: 1px dashed #ccc;
        }

        .node-duplicate {
            background-color: #fff3cd !important;
            border-color: #ffc107 !important;
            position: relative;
        }

        .node-duplicate::before {
            content: "⚠️";
            position: absolute;
            right: 4px;
            top: 4px;
            font-size: 10px;
            color: #856404;
        }

        .node-renamed {
            background-color: #e8f5e8 !important;
            border-color: #28a745 !important;
            position: relative;
        }

        .renamed-indicator {
            color: #28a745;
            font-size: 10px;
            margin-left: 4px;
            padding: 1px 3px;
            background: #d4edda;
            border-radius: 2px;
            border: 1px solid #c3e6cb;
        }

        .german-changed-indicator {
            color: #007bff;
            font-size: 10px;
            margin-left: 4px;
            padding: 1px 3px;
            background: #d1ecf1;
            border-radius: 2px;
            border: 1px solid #bee5eb;
        }

        /* Confirmation Modal Styles */
        .confirmation-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .confirmation-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        .confirmation-title {
            font-size: 20px;
            font-weight: bold;
            color: #dc3545;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .confirmation-message {
            font-size: 16px;
            margin-bottom: 25px;
            line-height: 1.5;
            color: #333;
        }

        .confirmation-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .confirmation-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .confirmation-btn.danger {
            background: #dc3545;
            color: white;
        }

        .confirmation-btn.danger:hover {
            background: #c82333;
        }

        .confirmation-btn.secondary {
            background: #6c757d;
            color: white;
        }

        .confirmation-btn.secondary:hover {
            background: #5a6268;
        }

        /* Floating Help Button */
        .floating-help {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .floating-help:hover {
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 123, 255, 0.4);
        }

        .floating-help:active {
            transform: translateY(0);
        }

        /* Search Arrow Indicators */
        .search-arrow {
            position: fixed;
            right: 10px;
            width: 0;
            height: 0;
            border-top: 12px solid transparent;
            border-bottom: 12px solid transparent;
            border-right: 20px solid #ff6b35;
            z-index: 500;
            animation: searchPulse 1.5s ease-in-out infinite;
            filter: drop-shadow(-2px 0 4px rgba(255, 107, 53, 0.3));
        }

        @keyframes searchPulse {

            0%,
            100% {
                opacity: 0.8;
                transform: translateX(0);
            }

            50% {
                opacity: 1;
                transform: translateX(-5px);
            }
        }

        .auto-save-indicator {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 10px;
            transition: all 0.3s;
        }

        .auto-save-indicator.saving {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .auto-save-indicator.saved {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .auto-save-indicator.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .duplicate-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 500px;
            max-height: 400px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid #e0e0e0;
            z-index: 200;
            display: none;
        }

        .duplicate-panel-header {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .duplicate-panel-header h3 {
            margin: 0;
            font-size: 14px;
            color: #333;
        }

        .duplicate-panel-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .duplicate-panel-close:hover {
            color: #333;
        }

        .duplicate-panel-content {
            max-height: 320px;
            overflow-y: auto;
            padding: 10px;
        }

        .duplicate-group {
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background: #f8f9fa;
        }

        .duplicate-group-header {
            padding: 8px 12px;
            background: #e9ecef;
            font-weight: 600;
            font-size: 12px;
            color: #495057;
            border-bottom: 1px solid #dee2e6;
        }

        .duplicate-item {
            padding: 8px 12px;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        .duplicate-item:last-child {
            border-bottom: none;
        }

        .duplicate-item:hover {
            background-color: #e9ecef;
        }

        .duplicate-item-name {
            font-weight: 500;
            color: #333;
        }

        .duplicate-item-path {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }

        /* Merge Functionality Styles */
        .merge-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .merge-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        .merge-btn:not(.cancel):not(.confirm) {
            background: #007bff;
            color: white;
        }

        .merge-btn:not(.cancel):not(.confirm):hover {
            background: #0056b3;
        }

        .merge-btn.cancel {
            background: #6c757d;
            color: white;
        }

        .merge-btn.cancel:hover {
            background: #545b62;
        }

        .merge-btn.confirm {
            background: #28a745;
            color: white;
        }

        .merge-btn.confirm:hover:not(:disabled) {
            background: #1e7e34;
        }

        .merge-btn:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
        }

        .merge-active {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .duplicate-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .duplicate-items.merge-mode .duplicate-item {
            border-left: 4px solid transparent;
            transition: all 0.3s;
        }

        .duplicate-item.merge-destination {
            background: #d4edda !important;
            border-left-color: #28a745 !important;
        }

        .duplicate-item.merge-source {
            background: #fff3cd !important;
            border-left-color: #ffc107 !important;
        }

        .merge-checkbox-container {
            padding: 8px 12px;
            border-bottom: 1px solid #e9ecef;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .merge-checkbox-container input[type="radio"] {
            margin: 0;
        }

        .merge-checkbox-container label {
            margin: 0;
            font-size: 12px;
            font-weight: 500;
            color: #495057;
            cursor: pointer;
        }

        /* Normalization Panel Styles */
        .normalization-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 700px;
            max-height: 80vh;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid #e0e0e0;
            z-index: 300;
            display: none;
        }

        .normalization-panel-header {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .normalization-panel-header h3 {
            margin: 0;
            color: #333;
            font-size: 16px;
        }

        .normalization-panel-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .normalization-panel-close:hover {
            background: #e9ecef;
            color: #333;
        }

        .normalization-panel-content {
            max-height: 50vh;
            overflow-y: auto;
            padding: 15px;
        }

        .normalization-panel-footer {
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            background: #f8f9fa;
            border-radius: 0 0 8px 8px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .normalization-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            margin-bottom: 8px;
            background: #f8f9fa;
        }

        .normalization-checkbox {
            margin-right: 12px;
            width: 18px;
            height: 18px;
            accent-color: #007ACC;
            cursor: pointer;
        }

        .normalization-item.selected {
            background: #e8f4fd;
            border-color: #007ACC;
        }

        .normalization-item.unselected {
            background: #f8f9fa;
            opacity: 0.7;
        }

        .normalization-before {
            flex: 1;
            font-family: monospace;
            color: #dc3545;
            font-weight: 500;
        }

        .normalization-arrow {
            margin: 0 15px;
            color: #6c757d;
            font-size: 18px;
        }

        .normalization-after {
            flex: 1;
            font-family: monospace;
            color: #28a745;
            font-weight: 500;
        }

        .normalization-summary {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #0c5460;
        }

        .normalization-controls {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .loading-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e9ecef;
            border-top: 4px solid #007ACC;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-indicator p {
            color: #6c757d;
            margin: 0;
            font-size: 14px;
        }

        .preserved-terms {
            margin-left: 15px;
            font-size: 11px;
            color: #28a745;
            background: #d4edda;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #c3e6cb;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        .select-all-container {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }

        .selection-summary {
            color: #6c757d;
            font-size: 13px;
        }

        .duplicate-item-content {
            padding: 10px 12px;
        }

        .duplicate-item.has-children {
            opacity: 0.6;
            background-color: #f8f9fa;
        }

        .duplicate-item.has-children .duplicate-item-name {
            color: #6c757d;
        }

        .merge-status {
            font-size: 11px;
            font-weight: bold;
            margin-top: 4px;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
        }

        .merge-status:contains("DESTINATION") {
            background: #d4edda;
            color: #155724;
        }

        .merge-status:contains("Will merge") {
            background: #fff3cd;
            color: #856404;
        }

        .merge-warning {
            font-size: 12px;
            color: #dc3545;
            font-weight: 500;
            padding: 4px 8px;
            background: #f8d7da;
            border-radius: 4px;
            border: 1px solid #f5c6cb;
        }

        .duplicate-item.has-children {
            opacity: 0.7;
            background: #f8f9fa !important;
        }

        .duplicate-item.has-children .duplicate-item-name {
            color: #6c757d;
        }

        .node-info {
            font-size: 10px;
            padding: 1px 6px;
            border-radius: 3px;
            background: #f5f5f5;
            color: #666666;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .children {
            margin-left: 28px;
            border-left: 1px solid #e0e0e0;
            padding-left: 16px;
            overflow: hidden;
            transition: all 0.4s ease;
        }

        .children.collapsed {
            max-height: 0;
            padding: 0;
            margin: 0;
            border: none;
        }

        .children.expanded {
            max-height: none;
        }

        .level-l1 .node-content {
            background: #f8f8f8;
            color: #333333;
            font-weight: bold;
            font-size: 14px;
            border: 2px solid #cccccc;
            padding: 8px 12px;
        }

        .level-l2 .node-content {
            background: #f5f5f5;
            color: #333333;
            font-weight: 600;
            border: 1px solid #d0d0d0;
            font-size: 13px;
        }

        .level-l3 .node-content {
            background: #f9f9f9;
            color: #333333;
            border: 1px solid #e0e0e0;
            font-size: 12px;
        }

        .level-l4 .node-content {
            background: #ffffff;
            color: #666666;
            border: 1px solid #e5e5e5;
            font-size: 12px;
        }

        .loading {
            text-align: center;
            padding: 60px;
            font-size: 18px;
            color: #6c757d;
        }

        .error {
            text-align: center;
            padding: 60px;
            color: #d32f2f;
            background: #ffffff;
            border-radius: 8px;
            margin: 20px;
            border: 1px solid #e0e0e0;
        }

        .performance-info {
            background: #f8f8f8;
            color: #333333;
            padding: 10px 20px;
            margin: 20px;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
            font-size: 14px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
            max-height: 80%;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #999;
        }

        .close:hover {
            color: #333;
        }

        @media (max-width: 768px) {
            .search-input {
                width: 100%;
                max-width: 300px;
            }

            body {
                padding-top: 120px;
                /* More space for wrapped toolbar on mobile */
            }

            .toolbar {
                padding: 10px 15px;
            }

            .toolbar-section {
                gap: 8px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        /* Bottom Navigation Toolbar */
        .bottom-toolbar {
            position: fixed;
            bottom: 20px;
            left: 120px;
            z-index: 98;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 0;
            align-items: center;
            font-size: 14px;
        }

        .nav-link {
            color: #007bff;
            text-decoration: none;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.3s ease;
            white-space: nowrap;
            cursor: pointer;
        }

        .nav-link:hover {
            background: rgba(0, 123, 255, 0.1);
            color: #0056b3;
        }

        .nav-link:disabled,
        .nav-link.disabled {
            color: #999;
            cursor: not-allowed;
            pointer-events: none;
        }

        .nav-separator {
            color: #666;
            margin: 0 5px;
            font-size: 12px;
        }

        @media (max-width: 768px) {
            .bottom-toolbar {
                bottom: 10px;
                left: 110px;
                padding: 8px 12px;
                font-size: 13px;
            }

            .nav-link {
                padding: 3px 6px;
            }

            .nav-separator {
                margin: 0 3px;
            }
        }
    </style>
</head>

<body>


    <div class="toolbar">
        <div class="toolbar-section">
            <button class="btn primary" onclick="showImportSection()">📁 Import CSV File</button>
            <button class="btn" onclick="clearDataWithConfirmation()" id="clearBtn" disabled>🗑️ Clear Data</button>
            <button class="btn" onclick="exportToCSV()" id="exportBtn" disabled>💾 Export CSV</button>
            <button class="btn" onclick="showNormalizationPreview()" id="normalizeBtn" disabled>🔧 Normalize
                Labels</button>
            <button class="btn" onclick="toggleEditMode()" id="editBtn" disabled>✏️ Edit Mode</button>
            <button class="btn" onclick="toggleDuplicateDetection()" id="duplicateBtn" disabled>🔍 Find
                Duplicates</button>
            <input type="text" class="search-input" id="searchInput"
                placeholder="Search nodes (English/German) - Press Enter to search..."
                onkeypress="handleSearchKeypress(event)" disabled>
            <button class="btn" onclick="clearSearch()" id="clearSearchBtn" disabled>Clear</button>
            <span id="autoSaveIndicator" class="auto-save-indicator"></span>
        </div>
    </div>

    <!-- Welcome Introduction -->
    <div id="welcomeIntroduction" style="background: white; margin: 20px; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); text-align: center;">
        <h3>🌳 Welcome to Interactive Organigram</h3>
        <p style="margin: 20px 0; font-size: 16px; line-height: 1.6;">
            Visualize your hierarchical data with powerful features: CSV Import/Export with drag & drop support, 
            inline editing by clicking any node name, duplicate detection and navigation, 
            interactive expand/collapse navigation, and mobile responsive design that works on all devices.
        </p>
        <p style="margin-top: 20px;"><strong>Get started by importing your CSV file below!</strong></p>
    </div>

    <div class="import-section" id="importSection">
        <div class="file-drop-area" onclick="triggerFileInput()">
            <div class="file-drop-icon">📤</div>
            <h3 style="margin: 0 0 10px 0; color: #333;">Import Your Data</h3>
            <p style="margin: 5px 0; font-size: 16px; color: #666;">Click here or drag & drop your CSV or Excel file</p>
            <p style="margin: 10px 0 0 0;"><small style="color: #999;">Required columns: name, id, pid, level | Optional: name_de, renamed, german_changed, merge</small></p>
            <input type="file" id="fileInput" class="file-input" accept=".csv,.xlsx,.xls"
                onchange="handleFileSelect(event)">
        </div>
        <div style="text-align: center; margin-top: 15px;">
            <button class="btn" onclick="showHelpModal()" style="margin-right: 10px;">❓ Need Help?</button>
            <button class="btn" onclick="downloadSample()">📥 Download Sample CSV</button>
        </div>
    </div>

    <div class="import-progress" id="importProgress">
        <h4>Processing File...</h4>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div id="progressText">Starting import...</div>
    </div>

    <div class="performance-info" id="performanceInfo" style="display: none;">
        <!-- Performance metrics will be shown here -->
    </div>

    <div class="stats-grid" id="statsGrid">
        <!-- Stats will be populated by JavaScript -->
    </div>

    <div class="tree-container">
        <div id="loading" class="loading">
            <h3>📊 Ready to Import</h3>
            <p>Your organigram will appear here once you import a CSV file above.</p>
        </div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="tree" class="tree" style="display: none;"></div>
    </div>

    <!-- Bottom Navigation Toolbar -->
    <div class="bottom-toolbar" id="bottomToolbar" style="display: none;">
        <a href="#" class="nav-link" onclick="event.preventDefault(); collapseAll();" id="collapseAllNav">Collapse All</a>
        <span class="nav-separator">></span>
        <a href="#" class="nav-link" onclick="event.preventDefault(); expandLevel(1);" id="expandL1Nav">Show L1</a>
        <span class="nav-separator">></span>
        <a href="#" class="nav-link" onclick="event.preventDefault(); expandLevel(2);" id="expandL2Nav">Show L1-2</a>
        <span class="nav-separator">></span>
        <a href="#" class="nav-link" onclick="event.preventDefault(); expandLevel(3);" id="expandL3Nav">Show L2-3</a>
    </div>

    <!-- Duplicate Detection Panel -->
    <div id="duplicatePanel" class="duplicate-panel">
        <div class="duplicate-panel-header">
            <h3>🔍 Duplicate Nodes</h3>
            <button class="duplicate-panel-close" onclick="closeDuplicatePanel()">×</button>
        </div>
        <div class="duplicate-panel-content" id="duplicateContent">
            <!-- Duplicate groups will be populated here -->
        </div>
    </div>

    <!-- Label Normalization Panel -->
    <div id="normalizationPanel" class="normalization-panel">
        <div class="normalization-panel-header">
            <h3>🔧 Label Normalization</h3>
            <button class="normalization-panel-close" onclick="closeNormalizationPanel()">×</button>
        </div>
        <div class="normalization-panel-content" id="normalizationContent">
            <!-- Normalization preview will be populated here -->
        </div>
        <div class="normalization-panel-footer">
            <button class="btn cancel" onclick="closeNormalizationPanel()">❌ Dismiss</button>
            <button class="btn primary" onclick="applyNormalization()">✅ Confirm Changes</button>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>📋 File Format Requirements</h3>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <div>
                <h4>Required Columns:</h4>
                <ul>
                    <li><strong>name</strong> - Node name/description (English)</li>
                    <li><strong>id</strong> - Unique identifier</li>
                    <li><strong>pid</strong> - Parent ID (NULL/empty for root nodes)</li>
                    <li><strong>level</strong> - Hierarchical level (l1, l2, l3, l4)</li>
                </ul>

                <h4>Optional Columns:</h4>
                <ul>
                    <li><strong>name_de</strong> - German translation of the node name</li>
                    <li><strong>renamed</strong> - TRUE/FALSE flag for edited English names</li>
                    <li><strong>german_changed</strong> - TRUE/FALSE flag for modified German translations</li>
                    <li><strong>merge</strong> - ID of the target node for duplicate merging</li>
                </ul>

                <h4>Example CSV:</h4>
                <pre>name,id,pid,level,name_de,german_changed,merge
"Company","1",NULL,"l1","Unternehmen","FALSE",""
"Engineering","2","1","l2","Entwicklung","FALSE",""
"Frontend Team","3","2","l3","Frontend-Team","FALSE",""
"John Doe","4","3","l4","Hans Müller","FALSE",""</pre>

                <h4>Editing Features:</h4>
                <ul>
                    <li><strong>Edit Mode</strong> - Click "✏️ Edit Mode" to enable label editing</li>
                    <li><strong>Click Labels</strong> - Click any node name to edit both English and German</li>
                    <li><strong>Dual Language</strong> - Edit both English name and German translation</li>
                    <li><strong>Save Changes</strong> - Press Enter to move between fields or click away to save</li>
                    <li><strong>Auto-Save</strong> - Changes are automatically saved to browser cache</li>
                    <li><strong>Renamed Tracking</strong> - Edited English names are marked with ✏️ and "renamed" column
                        set to TRUE</li>
                    <li><strong>German Change Tracking</strong> - Modified German translations are marked with "DE" and
                        "german_changed" column set to TRUE</li>
                    <li><strong>Export CSV</strong> - Download your edited data as CSV with both renamed and German
                        change flags</li>
                </ul>

                <h4>German Translation Features:</h4>
                <ul>
                    <li><strong>Side-by-Side Display</strong> - Shows "English | German" on the same row</li>
                    <li><strong>Optional Field</strong> - German translation is optional for each node</li>
                    <li><strong>Import/Export</strong> - Full support for German column in CSV files</li>
                    <li><strong>Inline Editing</strong> - Edit both languages simultaneously with side-by-side inputs
                    </li>
                    <li><strong>Bilingual Search</strong> - Search works in both English and German text</li>
                </ul>

                <h4>Auto-Save Features:</h4>
                <ul>
                    <li><strong>Session Cache</strong> - All changes saved automatically to browser storage</li>
                    <li><strong>Visual Indicators</strong> - Green highlighting for renamed nodes</li>
                    <li><strong>Status Display</strong> - Auto-save indicator shows save status in toolbar</li>
                    <li><strong>Renamed Column</strong> - CSV export includes TRUE/FALSE for edited nodes</li>
                </ul>

                <h4>Duplicate Detection & Merging:</h4>
                <ul>
                    <li><strong>Find Duplicates</strong> - Click "🔍 Find Duplicates" to scan for duplicate names</li>
                    <li><strong>Highlighting</strong> - Duplicate nodes are highlighted with yellow background</li>
                    <li><strong>Navigation Panel</strong> - Bottom-right panel shows all duplicates</li>
                    <li><strong>Click to Navigate</strong> - Click duplicate items to scroll to their location</li>
                    <li><strong>Merge Duplicates</strong> - Click "Merge" to start merge process</li>
                    <li><strong>Select Destination</strong> - Choose which node should be the merge target</li>
                    <li><strong>Confirm Merge</strong> - Confirm selection to mark duplicates for merging</li>
                    <li><strong>CSV Export</strong> - Merge information exported in "merge" column</li>
                </ul>

                <h4>Label Normalization:</h4>
                <ul>
                    <li><strong>Normalize Labels</strong> - Click "🔧 Normalize Labels" to standardize text formatting
                    </li>
                    <li><strong>Proper Case</strong> - Converts labels to proper case (First Letter Of Each Word)</li>
                    <li><strong>Exception Handling</strong> - Words like "e-mail" or "i-lithium" remain unchanged</li>
                    <li><strong>Preview Changes</strong> - Review all proposed changes before applying</li>
                    <li><strong>Edit Markers</strong> - Normalized nodes are marked with edit indicators</li>
                    <li><strong>CSV Export</strong> - Normalized labels included in exported data</li>
                </ul>

                <h4>Supported Formats:</h4>
                <ul>
                    <li>CSV files (.csv)</li>
                    <li>Excel files (.xlsx, .xls)</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        let nodesData = [];
        let flatNodesMap = new Map();
        let renderedNodes = new Set();
        let searchTerm = '';
        let loadingStartTime = Date.now();
        let totalNodes = 0;
        let editMode = false;
        let originalFileName = 'organigram_data';
        let duplicateDetectionActive = false;
        let duplicateGroups = new Map();

        // Auto-save and session management
        let sessionData = {
            originalData: null,
            modifiedNodes: new Map(),
            lastSaved: null,
            autoSaveEnabled: true
        };
        const AUTO_SAVE_DELAY = 1000; // 1 second after last change
        let autoSaveTimeout = null;

        // Auto-save and session management functions
        function initializeSession(data) {
            sessionData.originalData = JSON.parse(JSON.stringify(data));
            sessionData.modifiedNodes.clear();
            sessionData.lastSaved = Date.now();

            // Clear unsaved changes flag when initializing
            setUnsavedChanges(false);

            // Add 'renamed', 'german_changed', and 'mergeTarget' properties to all nodes
            function addRenamedProperty(nodes) {
                nodes.forEach(node => {
                    if (!node.hasOwnProperty('renamed')) {
                        node.renamed = false;
                    }
                    if (!node.hasOwnProperty('german_changed')) {
                        node.german_changed = false;
                    }
                    if (!node.hasOwnProperty('german')) {
                        node.german = null;
                    }
                    if (!node.hasOwnProperty('mergeTarget')) {
                        node.mergeTarget = null;
                    }
                    if (node.children && node.children.length > 0) {
                        addRenamedProperty(node.children);
                    }
                });
            }

            addRenamedProperty(nodesData);
            saveSession();
            updatePerformanceInfo('Session initialized - Auto-save enabled');
        }

        function saveSession() {
            try {
                const sessionState = {
                    originalData: sessionData.originalData,
                    modifiedNodes: Array.from(sessionData.modifiedNodes.entries()),
                    lastSaved: Date.now(),
                    fileName: originalFileName,
                    timestamp: new Date().toISOString()
                };

                localStorage.setItem('organigram_session', JSON.stringify(sessionState));
                sessionData.lastSaved = Date.now();

                // Clear unsaved changes flag
                setUnsavedChanges(false);

                // Update UI indicator
                updateAutoSaveIndicator('saved');
            } catch (error) {
                console.error('Failed to save session:', error);
                updateAutoSaveIndicator('error');
            }
        }

        function loadSession() {
            try {
                const saved = localStorage.getItem('organigram_session');
                if (!saved) return false;

                const sessionState = JSON.parse(saved);
                sessionData.originalData = sessionState.originalData;
                sessionData.modifiedNodes = new Map(sessionState.modifiedNodes);
                sessionData.lastSaved = sessionState.lastSaved;

                if (sessionState.fileName) {
                    originalFileName = sessionState.fileName;
                }

                return true;
            } catch (error) {
                console.error('Failed to load session:', error);
                return false;
            }
        }

        function markNodeAsRenamed(nodeId, newName, oldName) {
            const node = flatNodesMap.get(nodeId);
            if (!node) return;

            // Update the node data
            node.name = newName;
            node.renamed = true;

            // Track the modification
            sessionData.modifiedNodes.set(nodeId, {
                originalName: oldName,
                newName: newName,
                timestamp: Date.now(),
                renamed: true
            });

            // Trigger auto-save
            scheduleAutoSave();

            // Update visual indicator
            updateNodeVisualState(nodeId);
        }

        function markGermanAsChanged(nodeId, newGerman, oldGerman) {
            const node = flatNodesMap.get(nodeId);
            if (!node) return;

            // Update the node data
            node.german = newGerman || null;
            node.german_changed = true;

            // Track the modification
            const existingModification = sessionData.modifiedNodes.get(nodeId) || {};
            sessionData.modifiedNodes.set(nodeId, {
                ...existingModification,
                originalGerman: oldGerman,
                newGerman: newGerman,
                timestamp: Date.now(),
                german_changed: true
            });

            // Trigger auto-save
            scheduleAutoSave();

            // Update visual indicator
            updateNodeVisualState(nodeId);
        }

        function scheduleAutoSave() {
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }

            // Mark as having unsaved changes
            setUnsavedChanges(true);
            updateAutoSaveIndicator('saving');

            autoSaveTimeout = setTimeout(() => {
                saveSession();
                setUnsavedChanges(false); // Clear unsaved flag after successful save
                updatePerformanceInfo(`Auto-saved ${sessionData.modifiedNodes.size} modifications`);
            }, AUTO_SAVE_DELAY);
        }

        function updateAutoSaveIndicator(status) {
            const indicator = document.getElementById('autoSaveIndicator');
            if (!indicator) return;

            const indicators = {
                'saving': '💾 Saving...',
                'saved': '✅ Saved',
                'error': '❌ Save Error'
            };

            indicator.textContent = indicators[status] || '';
            indicator.className = `auto-save-indicator ${status}`;
        }

        function updateNodeVisualState(nodeId) {
            const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
            if (!nodeElement) return;

            const node = flatNodesMap.get(nodeId);
            const content = nodeElement.querySelector('.node-content');
            if (!content) return;

            // Handle renamed indicator
            if (node && node.renamed) {
                nodeElement.classList.add('node-renamed');

                // Add renamed indicator if not present
                if (!content.querySelector('.renamed-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'renamed-indicator';
                    indicator.textContent = '✏️';
                    indicator.title = 'This node has been renamed';
                    content.appendChild(indicator);
                }
            }

            // Handle German changed indicator
            if (node && node.german_changed) {
                // Add German changed indicator if not present
                if (!content.querySelector('.german-changed-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'german-changed-indicator';
                    indicator.textContent = 'DE';
                    indicator.title = 'German translation has been modified';
                    content.appendChild(indicator);
                }
            }
        }

        function getModificationStats() {
            return {
                totalModifications: sessionData.modifiedNodes.size,
                lastSaved: sessionData.lastSaved,
                hasUnsavedChanges: autoSaveTimeout !== null
            };
        }

        function clearSession() {
            localStorage.removeItem('organigram_session');
            sessionData.originalData = null;
            sessionData.modifiedNodes.clear();
            sessionData.lastSaved = null;
            updatePerformanceInfo('Session cleared');
        }

        // File handling
        function showImportSection() {
            console.log('Showing import section and welcome introduction');
            const importSection = document.getElementById('importSection');
            const welcomeIntroduction = document.getElementById('welcomeIntroduction');
            
            importSection.classList.remove('hidden');
            welcomeIntroduction.classList.remove('hidden');
            
            welcomeIntroduction.scrollIntoView({ behavior: 'smooth' });
        }

        function clearData() {
            nodesData = [];
            flatNodesMap.clear();
            renderedNodes.clear();
            totalNodes = 0;

            // Clear session data
            clearSession();

            document.getElementById('tree').innerHTML = '';
            document.getElementById('tree').style.display = 'none';
            document.getElementById('statsGrid').innerHTML = '';
            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';
            document.getElementById('performanceInfo').style.display = 'none';

            // Reset duplicate detection
            if (duplicateDetectionActive) {
                toggleDuplicateDetection();
            }

            // Reset edit mode
            if (editMode) {
                toggleEditMode();
            }

            showImportSection();
            updatePerformanceInfo('Data cleared - Please import a CSV file to get started');
            updateToolbarState(false); // Disable data-dependent buttons
        }

        function handleFileSelect(event) {
            console.log('File select event triggered');
            const file = event.target.files[0];
            if (file) {
                console.log('File selected:', file.name, 'Size:', file.size, 'Type:', file.type);
                processFile(file);
            } else {
                console.log('No file selected');
            }
        }

        function triggerFileInput() {
            console.log('Triggering file input click');
            document.getElementById('fileInput').click();
        }

        function processFile(file) {
            console.log('Processing file:', file.name);
            originalFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove extension
            const fileName = file.name;
            const fileExt = fileName.split('.').pop().toLowerCase();

            if (!['csv', 'xlsx', 'xls'].includes(fileExt)) {
                showError('Unsupported file format. Please use CSV or Excel files.');
                return;
            }

            showProgress(true);
            updateProgress(10, 'Reading file...');

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    console.log('File read successfully, size:', e.target.result.length);
                    if (fileExt === 'csv') {
                        processCSV(e.target.result);
                    } else {
                        showError('Excel files require server-side processing. Please convert to CSV format.');
                        showProgress(false);
                    }
                } catch (error) {
                    console.error('Error processing file:', error);
                    showError(`Error processing file: ${error.message}`);
                    showProgress(false);
                }
            };

            reader.onerror = function () {
                console.error('Error reading file');
                showError('Error reading file. Please try again.');
                showProgress(false);
            };

            reader.readAsText(file);
        }

        function processCSV(csvText) {
            try {
                updateProgress(30, 'Parsing CSV data...');

                const lines = csvText.split('\n').filter(line => line.trim());
                if (lines.length < 2) {
                    throw new Error('CSV file appears to be empty or invalid');
                }

                const headers = parseCSVLine(lines[0]);
                const requiredColumns = ['name', 'id', 'pid', 'level'];

                // Validate headers
                const missingColumns = requiredColumns.filter(col => !headers.includes(col));
                if (missingColumns.length > 0) {
                    throw new Error(`Missing required columns: ${missingColumns.join(', ')}`);
                }

                // Check if optional columns exist
                const hasRenamedColumn = headers.includes('renamed');
                const hasGermanColumn = headers.includes('name_de');
                const hasGermanChangedColumn = headers.includes('german_changed');
                const hasMergeColumn = headers.includes('merge');

                updateProgress(50, 'Processing nodes...');

                const nodes = {};
                const childrenMap = new Map();

                for (let i = 1; i < lines.length; i++) {
                    const values = parseCSVLine(lines[i]);
                    if (values.length !== headers.length) continue;

                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index];
                    });

                    const nodeId = cleanField(row.id);
                    const pid = cleanField(row.pid);
                    const name = cleanField(row.name);
                    const level = cleanField(row.level);
                    const renamed = hasRenamedColumn ?
                        (cleanField(row.renamed) === 'TRUE' || cleanField(row.renamed) === 'true') :
                        false;
                    const german = hasGermanColumn ? cleanField(row.name_de) : null;
                    const germanChanged = hasGermanChangedColumn ?
                        (cleanField(row.german_changed) === 'TRUE' || cleanField(row.german_changed) === 'true') :
                        false;
                    const mergeTarget = hasMergeColumn ? cleanField(row.merge) : null;

                    if (!nodeId || !name) continue;

                    nodes[nodeId] = {
                        id: nodeId,
                        name: name,
                        pid: pid,
                        level: level || 'unknown',
                        renamed: renamed,
                        german: german,
                        german_changed: germanChanged,
                        mergeTarget: mergeTarget,
                        children: []
                    };

                    if (pid) {
                        if (!childrenMap.has(pid)) {
                            childrenMap.set(pid, []);
                        }
                        childrenMap.get(pid).push(nodeId);
                    }
                }

                updateProgress(70, 'Building hierarchy...');

                // Add children to nodes
                for (const [parentId, childIds] of childrenMap) {
                    if (nodes[parentId]) {
                        nodes[parentId].children = childIds.map(id => nodes[id]).filter(Boolean);
                    }
                }

                updateProgress(90, 'Finalizing...');

                // Create hierarchy
                const hierarchy = Object.values(nodes)
                    .filter(node => !node.pid)
                    .map(rootNode => buildTree(rootNode, nodes));

                nodesData = hierarchy;
                buildFlatNodeMap(nodesData);

                // Initialize session for auto-save
                initializeSession(nodesData);

                updateProgress(100, 'Complete!');

                setTimeout(() => {
                    showProgress(false);
                    hideImportSection();
                    displayStats();
                    renderTree();
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('tree').style.display = 'block';
                    updatePerformanceInfo(`Successfully imported ${totalNodes.toLocaleString()} nodes`);
                    updateToolbarState(true); // Enable all buttons after successful import
                }, 1000);

            } catch (error) {
                showError(`Error processing CSV: ${error.message}`);
                showProgress(false);
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];

                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        current += '"';
                        i++; // Skip next quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }

            result.push(current);
            return result;
        }

        function cleanField(field) {
            if (!field || field === 'NULL' || field === '') {
                return null;
            }
            return String(field).trim().replace(/^["']|["']$/g, '');
        }

        function buildTree(node, allNodes) {
            const result = { ...node };
            result.children = node.children.map(child => buildTree(child, allNodes));
            return result;
        }

        function hideImportSection() {
            console.log('Hiding import section and welcome introduction');
            document.getElementById('importSection').classList.add('hidden');
            document.getElementById('welcomeIntroduction').classList.add('hidden');
        }

        function showProgress(show) {
            const progress = document.getElementById('importProgress');
            progress.style.display = show ? 'block' : 'none';
            if (!show) {
                updateProgress(0, '');
            }
        }

        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = `${percent}%`;
            document.getElementById('progressText').textContent = text;
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.innerHTML = `<h3>⚠️ Error</h3><p>${message}</p>`;
            errorDiv.style.display = 'block';
            document.getElementById('loading').style.display = 'none';
            document.getElementById('tree').style.display = 'none';
        }

        // Drag and drop
        const importSection = document.getElementById('importSection');

        importSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            importSection.classList.add('dragover');
        });

        importSection.addEventListener('dragleave', (e) => {
            e.preventDefault();
            importSection.classList.remove('dragover');
        });

        importSection.addEventListener('drop', (e) => {
            e.preventDefault();
            importSection.classList.remove('dragover');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        });

        // Modal functions
        function showHelpModal() {
            document.getElementById('helpModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('helpModal').style.display = 'none';
        }

        function downloadSample() {
            const sampleCSV = `name,id,pid,level,renamed,name_de,german_changed,merge
"Company","1",,"l1","FALSE","Unternehmen","FALSE",""
"Engineering","2","1","l2","FALSE","Entwicklung","FALSE",""
"Product","3","1","l2","FALSE","Produkt","FALSE",""
"Frontend Team","4","2","l3","FALSE","Frontend-Team","FALSE",""
"Backend Team","5","2","l3","FALSE","Backend-Team","FALSE",""
"Design Team","6","3","l3","FALSE","Design-Team","FALSE",""
"John Doe","7","4","l4","FALSE","Hans Müller","FALSE",""
"Jane Smith","8","4","l4","FALSE","Jana Schmidt","FALSE",""
"Bob Wilson","9","5","l4","FALSE","Robert Weber","FALSE",""
"Alice Johnson","10","6","l4","FALSE","Alicia Jung","FALSE",""`;

            const blob = new Blob([sampleCSV], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sample_organigram.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        // Edit Mode Functions
        function toggleEditMode() {
            if (nodesData.length === 0) {
                alert('No data loaded. Please import a CSV file first.');
                return;
            }

            editMode = !editMode;
            const button = event.target;
            const treeContainer = document.getElementById('tree');

            if (editMode) {
                button.textContent = '✅ Save Mode';
                button.classList.add('primary');
                treeContainer.classList.add('edit-mode');
                updatePerformanceInfo('Edit mode enabled - Click on any label to edit');
            } else {
                button.textContent = '✏️ Edit Mode';
                button.classList.remove('primary');
                treeContainer.classList.remove('edit-mode');
                updatePerformanceInfo('Edit mode disabled');
            }
        }

        function makeNodeEditable(nodeElement, node) {
            if (!editMode) return;

            const label = nodeElement.querySelector('.node-label');
            if (label.querySelector('input')) return; // Already editing

            const currentText = node.name;
            const currentGerman = node.german || '';

            // Create editing interface with side-by-side inputs
            label.innerHTML = `
                <div style="display: flex; align-items: center; gap: 6px; width: 100%;">
                    <input type="text" value="${currentText}" placeholder="English name" 
                           onblur="saveNodeEdit(this, '${node.id}', 'name')" 
                           onkeypress="handleEditKeypress(event, this, '${node.id}', 'name')"
                           style="font-weight: 500; font-size: 13px; flex: 1; min-width: 120px; border: 1px solid #ccc; padding: 2px 4px; border-radius: 2px;">
                    <span style="color: #999; font-size: 12px;">|</span>
                    <input type="text" value="${currentGerman}" placeholder="German (optional)" 
                           onblur="saveNodeEdit(this, '${node.id}', 'german')" 
                           onkeypress="handleEditKeypress(event, this, '${node.id}', 'german')"
                           style="font-size: 12px; color: #666; font-style: italic; flex: 1; min-width: 120px; border: 1px solid #ccc; padding: 2px 4px; border-radius: 2px;">
                </div>
            `;

            const firstInput = label.querySelector('input');
            firstInput.focus();
            firstInput.select();
        }

        function saveNodeEdit(input, nodeId, fieldType) {
            const newValue = input.value.trim();

            // Get the current node data
            const node = flatNodesMap.get(nodeId);
            if (!node) return;

            if (fieldType === 'name') {
                if (newValue === '') {
                    input.focus();
                    return;
                }

                const oldName = node.name;

                // Only mark as renamed if the name actually changed
                if (oldName !== newValue) {
                    markNodeAsRenamed(nodeId, newValue, oldName);
                    updatePerformanceInfo(`Updated node: ${nodeId} -> "${newValue}" (Auto-saved)`);
                } else {
                    node.name = newValue;
                }
            } else if (fieldType === 'german') {
                // German translation can be empty
                const oldGerman = node.german || '';
                if (oldGerman !== newValue) {
                    markGermanAsChanged(nodeId, newValue, oldGerman);
                    updatePerformanceInfo(`Updated German translation for node: ${nodeId} (Auto-saved)`);
                }
            }

            // Don't restore display immediately - let user continue editing
            // Only restore when they click outside the entire editing area
            // Use a timeout to check if focus moved to another input in the same node
            setTimeout(() => {
                const label = input.closest('.node-label');
                const activeElement = document.activeElement;
                const isStillEditingThisNode = label && label.contains(activeElement) && activeElement.tagName === 'INPUT';

                if (!isStillEditingThisNode) {
                    // Check if English field is empty (required field)
                    const englishInput = label.querySelector('input[placeholder*="English"]');
                    if (englishInput && englishInput.value.trim() === '') {
                        englishInput.focus();
                        return;
                    }

                    // Restore the display
                    restoreNodeDisplay(nodeId);
                }
            }, 50);
        }

        function restoreNodeDisplay(nodeId) {
            const node = flatNodesMap.get(nodeId);
            if (!node) return;

            const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
            const label = nodeElement.querySelector('.node-label');

            // Clear the editing interface
            label.innerHTML = '';

            // Create main name element
            const mainName = document.createElement('span');
            mainName.className = 'node-label-main';
            mainName.textContent = node.name;
            label.appendChild(mainName);

            // Add German translation if available
            if (node.german && node.german.trim()) {
                const separator = document.createElement('span');
                separator.className = 'node-label-separator';
                separator.textContent = '|';
                label.appendChild(separator);

                const germanName = document.createElement('span');
                germanName.className = 'node-label-german';
                germanName.textContent = node.german;
                label.appendChild(germanName);
            }
        }

        function handleEditKeypress(event, input, nodeId, fieldType) {
            if (event.key === 'Enter') {
                if (fieldType === 'name') {
                    // Move to German field if available
                    const germanInput = input.parentElement.querySelector('input[placeholder*="German"]');
                    if (germanInput) {
                        germanInput.focus();
                    } else {
                        input.blur();
                    }
                } else {
                    input.blur();
                }
            } else if (event.key === 'Escape') {
                // Restore original values
                restoreNodeDisplay(nodeId);
            }
        }

        // Export Functions
        function exportToCSV() {
            if (nodesData.length === 0) {
                alert('No data to export. Please import a CSV file first.');
                return;
            }

            const csvContent = generateCSVFromNodes();
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = window.URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${originalFileName}_edited.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);

            updatePerformanceInfo(`Exported ${totalNodes} nodes to CSV`);
        }

        function generateCSVFromNodes() {
            const rows = ['name,id,pid,level,renamed,name_de,german_changed,merge'];

            function addNodeToCSV(node) {
                const name = `"${node.name.replace(/"/g, '""')}"`;
                const id = `"${node.id}"`;
                const pid = node.pid ? `"${node.pid}"` : '';
                const level = `"${node.level}"`;
                const renamed = node.renamed ? 'TRUE' : 'FALSE';
                const german = node.german ? `"${node.german.replace(/"/g, '""')}"` : '';
                const germanChanged = node.german_changed ? 'TRUE' : 'FALSE';
                const merge = node.mergeTarget ? `"${node.mergeTarget}"` : '';

                rows.push(`${name},${id},${pid},${level},${renamed},${german},${germanChanged},${merge}`);

                if (node.children && node.children.length > 0) {
                    node.children.forEach(child => addNodeToCSV(child));
                }
            }

            nodesData.forEach(rootNode => addNodeToCSV(rootNode));
            return rows.join('\n');
        }

        // Duplicate Detection Functions
        function toggleDuplicateDetection() {
            if (nodesData.length === 0) {
                alert('No data loaded. Please import a CSV file first.');
                return;
            }

            duplicateDetectionActive = !duplicateDetectionActive;
            const button = event.target;

            if (duplicateDetectionActive) {
                button.textContent = '✅ Hide Duplicates';
                button.classList.add('primary');
                findAndHighlightDuplicates();
                showDuplicatePanel();
                updatePerformanceInfo('Duplicate detection enabled');
            } else {
                button.textContent = '🔍 Find Duplicates';
                button.classList.remove('primary');
                clearDuplicateHighlights();
                closeDuplicatePanel();
                updatePerformanceInfo('Duplicate detection disabled');
            }
        }

        function findAndHighlightDuplicates() {
            duplicateGroups.clear();

            // Group nodes by parent and name
            const parentGroups = new Map();

            flatNodesMap.forEach((node, nodeId) => {
                const parentId = node.pid || 'ROOT';
                const nodeName = node.name.toLowerCase().trim();

                if (!parentGroups.has(parentId)) {
                    parentGroups.set(parentId, new Map());
                }

                const parentGroup = parentGroups.get(parentId);
                if (!parentGroup.has(nodeName)) {
                    parentGroup.set(nodeName, []);
                }

                parentGroup.get(nodeName).push(node);
            });

            // Find duplicates within each parent group
            parentGroups.forEach((nameGroups, parentId) => {
                nameGroups.forEach((nodes, nodeName) => {
                    if (nodes.length > 1) {
                        const parentNode = flatNodesMap.get(parentId) || { name: 'Root Level' };
                        const groupKey = `${parentId}_${nodeName}`;
                        duplicateGroups.set(groupKey, {
                            parentName: parentNode.name,
                            nodeName: nodes[0].name, // Original case
                            nodes: nodes
                        });
                    }
                });
            });

            // Highlight duplicate nodes
            duplicateGroups.forEach(group => {
                group.nodes.forEach(node => {
                    const nodeElement = document.querySelector(`[data-id="${node.id}"] .node-content`);
                    if (nodeElement) {
                        nodeElement.classList.add('node-duplicate');
                    }
                });
            });

            updateDuplicatePanel();
        }

        function clearDuplicateHighlights() {
            document.querySelectorAll('.node-duplicate').forEach(element => {
                element.classList.remove('node-duplicate');
            });
            duplicateGroups.clear();
            
            // Reset the header title when clearing duplicates
            const header = document.querySelector('#duplicatePanel .duplicate-panel-header h3');
            if (header) {
                header.textContent = '🔍 Duplicate Nodes';
            }
        }

        function showDuplicatePanel() {
            document.getElementById('duplicatePanel').style.display = 'block';
        }

        function closeDuplicatePanel() {
            const panel = document.getElementById('duplicatePanel');
            const header = document.querySelector('#duplicatePanel .duplicate-panel-header h3');
            
            panel.style.display = 'none';
            
            // Reset the header title when closing
            if (header) {
                header.textContent = '🔍 Duplicate Nodes';
            }
        }

        function updateDuplicatePanel() {
            const content = document.getElementById('duplicateContent');
            const header = document.querySelector('#duplicatePanel .duplicate-panel-header h3');

            // Calculate total number of duplicate nodes
            let totalDuplicates = 0;
            duplicateGroups.forEach(group => {
                totalDuplicates += group.nodes.length;
            });

            // Update the header title with count
            if (header) {
                header.textContent = `🔍 Duplicate Nodes (${totalDuplicates})`;
            }

            if (duplicateGroups.size === 0) {
                if (header) {
                    header.textContent = '🔍 Duplicate Nodes';
                }
                content.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No duplicates found within the same categories.</div>';
                return;
            }

            let html = '<div style="margin-bottom: 15px; padding: 10px; background: #e8f4fd; border-radius: 5px; font-size: 14px;"><strong>Duplicate Merge Tool:</strong> Only leaf nodes (nodes without children) can be merged. Click "Merge" to select which node should be the merge destination.</div>';

            duplicateGroups.forEach((group, groupKey) => {
                const mergeStatus = getMergeStatusForGroup(group, groupKey);
                const hasActiveMerge = mergeStatus.hasPendingMerge;
                const hasLeafNodes = group.nodes.some(node => isLeafNode(node));
                const leafNodeCount = group.nodes.filter(node => isLeafNode(node)).length;

                html += `
                    <div class="duplicate-group" data-group-key="${groupKey}">
                        <div class="duplicate-group-header">
                            <div>"${group.nodeName}" in ${group.parentName} (${leafNodeCount} mergeable of ${group.nodes.length} total)</div>
                            <div class="merge-controls">
                                ${hasLeafNodes && leafNodeCount >= 2 ? (
                        !hasActiveMerge ?
                            `<button class="merge-btn" onclick="startMerge('${groupKey}')">Merge</button>` :
                            `<div class="merge-active">
                                            <button class="merge-btn cancel" onclick="cancelMerge('${groupKey}')">❌ Cancel</button>
                                            <button class="merge-btn confirm" onclick="confirmMerge('${groupKey}')" ${!mergeStatus.hasSelection ? 'disabled' : ''}>✅ Confirm</button>
                                        </div>`
                    ) : ''}
                            </div>
                        </div>
                        <div class="duplicate-items ${hasActiveMerge ? 'merge-mode' : ''}">
                `;

                group.nodes.forEach((node, index) => {
                    const path = getNodePath(node);
                    const isSelected = mergeStatus.selectedDestination === node.id;
                    const willBeMerged = mergeStatus.sourceNodes.includes(node.id);
                    const hasChildren = !isLeafNode(node);

                    // Only show this node if it's a leaf node OR if there's no active merge
                    if (hasActiveMerge && hasChildren) {
                        return; // Skip non-leaf nodes when merge is active
                    }

                    html += `
                        <div class="duplicate-item ${isSelected ? 'merge-destination' : ''} ${willBeMerged ? 'merge-source' : ''}" onclick="scrollToNode('${node.id}')">
                            ${hasActiveMerge && !hasChildren ? `
                                <div class="merge-checkbox-container">
                                    <input type="radio" id="merge-${groupKey}-${node.id}" name="merge-destination-${groupKey}" value="${node.id}" 
                                           onchange="selectMergeDestination('${groupKey}', '${node.id}')" 
                                           ${isSelected ? 'checked' : ''}
                                           onclick="event.stopPropagation()">
                                    <label for="merge-${groupKey}-${node.id}">Select as destination</label>
                                </div>
                            ` : ''}
                            <div class="duplicate-item-content">
                                <div class="duplicate-item-name">${node.name} (ID: ${node.id})</div>
                                <div class="duplicate-item-path">${path}</div>
                                ${hasActiveMerge && isSelected && !hasChildren ? '<div class="merge-status">📍 DESTINATION</div>' : ''}
                                ${hasActiveMerge && willBeMerged && !hasChildren ? '<div class="merge-status">➡️ Will merge to destination</div>' : ''}
                            </div>
                        </div>
                    `;
                });

                html += '</div></div>';
            });

            content.innerHTML = html;
        }

        function getNodePath(node) {
            const path = [];
            let current = node;

            while (current && current.pid) {
                const parent = flatNodesMap.get(current.pid);
                if (parent) {
                    path.unshift(parent.name);
                    current = parent;
                } else {
                    break;
                }
            }

            return path.length > 0 ? path.join(' > ') : 'Root Level';
        }

        // Label Normalization Functionality
        let normalizationCorrections = [];
        let selectedCorrections = new Set();

        // Configuration for normalization service
        const NORMALIZATION_SERVICE_URL = 'http://localhost:5000';

        async function normalizeWithService(labels) {
            console.log('🔍 Starting normalization with service for labels:', labels);
            try {
                console.log('📡 Fetching from:', `${NORMALIZATION_SERVICE_URL}/normalize`);
                const response = await fetch(`${NORMALIZATION_SERVICE_URL}/normalize`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ labels: labels })
                });

                console.log('📡 Response status:', response.status);

                if (!response.ok) {
                    throw new Error(`Service responded with status: ${response.status}`);
                }

                const data = await response.json();
                console.log('📊 Service response data:', data);

                if (!data.success) {
                    throw new Error(data.error || 'Normalization service error');
                }

                console.log('✅ Normalization successful, returning results');
                return data.results;
            } catch (error) {
                console.error('❌ Normalization service error:', error);
                console.warn('🔄 Normalization service unavailable, falling back to basic normalization');
                // Fallback to basic normalization
                return labels.map(label => ({
                    original: label,
                    normalized: toProperCaseBasic(label),
                    changed: label !== toProperCaseBasic(label),
                    preserved_terms: [],
                    normalized_words: []
                }));
            }
        }

        function toProperCaseBasic(str) {
            if (!str) return str;

            // Known technical terms that should be uppercase
            const technicalTerms = ['ECU', 'DC', 'AC', 'EV', 'ABS', 'LED', 'GPS', 'USB', 'CPU', 'GPU', 'RAM', 'ROM'];
            
            // Basic fallback normalization (used when service is unavailable)
            const preservePatterns = [
                /\be-mail\b/gi,
                /\bi-\w+\b/gi,
                /\be-\w+\b/gi  // e-prefixed words like e-Axle
            ];

            // Check if the string contains preserve patterns - if so, handle carefully
            let hasPreservePattern = false;
            for (const pattern of preservePatterns) {
                if (pattern.test(str)) {
                    hasPreservePattern = true;
                    break;
                }
            }

            if (hasPreservePattern) {
                // For strings with preserve patterns, be more careful
                return str.replace(/\b\w+/g, (word) => {
                    // Check if this specific word should be preserved as lowercase
                    if (/^e-\w+$/i.test(word) || /^i-\w+$/i.test(word)) {
                        return word.toLowerCase();
                    }
                    // Check if it's a technical term
                    if (technicalTerms.includes(word.toUpperCase())) {
                        return word.toUpperCase();
                    }
                    // Preserve all-caps words that are likely acronyms
                    if (word.length <= 6 && word === word.toUpperCase() && /^[A-Z]+$/.test(word)) {
                        return word;
                    }
                    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
                });
            }

            // Regular proper case conversion
            return str.replace(/\b\w+/g, (word) => {
                // Check if it's a technical term first
                if (technicalTerms.includes(word.toUpperCase())) {
                    return word.toUpperCase();
                }
                // Preserve all-caps words that are likely acronyms  
                if (word.length <= 6 && word === word.toUpperCase() && /^[A-Z]+$/.test(word)) {
                    return word;
                }
                // Handle hyphenated technical terms like DC-AC
                if (word.includes('-')) {
                    return word.split('-').map(part => {
                        // Check if it's a technical term
                        if (technicalTerms.includes(part.toUpperCase())) {
                            return part.toUpperCase();
                        }
                        // Preserve already uppercase acronym parts
                        if (part.length <= 6 && part === part.toUpperCase() && /^[A-Z]+$/.test(part)) {
                            return part;
                        }
                        return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
                    }).join('-');
                }
                return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
            });
        }

        function toProperCase(text) {
            return toProperCaseBasic(text);
        }

        async function generateNormalizationCorrections() {
            console.log('🔄 Starting generateNormalizationCorrections');
            normalizationCorrections = [];
            selectedCorrections.clear();

            // Collect all node names
            const nodeLabels = [];
            const nodeMap = new Map();

            function collectNodes(node) {
                nodeLabels.push(node.name);
                nodeMap.set(node.name, node);

                if (node.children) {
                    node.children.forEach(child => collectNodes(child));
                }
            }

            console.log('📊 Checking nodesData:', nodesData);
            nodesData.forEach(rootNode => collectNodes(rootNode));
            console.log('📝 Collected node labels:', nodeLabels);

            try {
                // Use intelligent normalization service
                console.log('🚀 Calling normalizeWithService...');
                const results = await normalizeWithService(nodeLabels);
                console.log('📊 Service results:', results);

                results.forEach((result, index) => {
                    if (result.changed) {
                        const node = nodeMap.get(result.original);
                        if (node) {
                            const correctionId = `correction_${node.id}`;

                            normalizationCorrections.push({
                                id: correctionId,
                                nodeId: node.id,
                                original: result.original,
                                normalized: result.normalized,
                                node: node,
                                preservedTerms: result.preserved_terms || [],
                                normalizedWords: result.normalized_words || []
                            });

                            // Select all by default
                            selectedCorrections.add(correctionId);
                        }
                    }
                });

            } catch (error) {
                console.error('Error generating normalization corrections:', error);
                // Fallback to basic normalization
                function checkNodeBasic(node) {
                    const originalName = node.name;
                    const normalizedName = toProperCaseBasic(originalName);

                    if (originalName !== normalizedName) {
                        const correctionId = `correction_${node.id}`;
                        normalizationCorrections.push({
                            id: correctionId,
                            nodeId: node.id,
                            original: originalName,
                            normalized: normalizedName,
                            node: node,
                            preservedTerms: [],
                            normalizedWords: []
                        });
                        // Select all by default
                        selectedCorrections.add(correctionId);
                    }

                    if (node.children) {
                        node.children.forEach(child => checkNodeBasic(child));
                    }
                }

                nodesData.forEach(rootNode => checkNodeBasic(rootNode));
            }

            return normalizationCorrections;
        }

        async function showNormalizationPreview() {
            // Show loading state
            const panel = document.getElementById('normalizationPanel');
            panel.style.display = 'block';

            // Update just the content area, not the entire panel
            const content = document.getElementById('normalizationContent');
            content.innerHTML = `
                <div class="loading-indicator">
                    <div class="spinner"></div>
                    <p>🔍 Analyzing labels for technical terms and acronyms...</p>
                </div>
            `;

            try {
                const corrections = await generateNormalizationCorrections();

                if (corrections.length === 0) {
                    closeNormalizationPanel();
                    showConfirmationModal(
                        'No Changes Needed',
                        'All node labels are already properly formatted, and all technical terms/acronyms have been preserved.',
                        function () { }
                    );
                    return;
                }

                updateNormalizationPanel(corrections);
            } catch (error) {
                console.error('Error in normalization preview:', error);
                closeNormalizationPanel();
                showConfirmationModal(
                    'Normalization Error',
                    'There was an error analyzing the labels. Please try again.',
                    function () { }
                );
            }
        }

        function updateNormalizationPanel(corrections) {
            const content = document.getElementById('normalizationContent');

            // Count preserved terms across all corrections
            const allPreservedTerms = new Set();
            corrections.forEach(correction => {
                if (correction.preservedTerms) {
                    correction.preservedTerms.forEach(term => allPreservedTerms.add(term));
                }
            });

            const preservedCount = allPreservedTerms.size;
            const preservedTermsList = Array.from(allPreservedTerms).slice(0, 5); // Show first 5

            let html = `
                <div class="normalization-summary">
                    <strong>🤖 Intelligent Normalization Preview</strong><br>
                    Found ${corrections.length} labels that can be normalized to Proper Case.<br>
                    ${preservedCount > 0 ?
                    `<small>✅ ${preservedCount} technical terms/acronyms preserved: ${preservedTermsList.join(', ')}${preservedCount > 5 ? '...' : ''}</small>` :
                    '<small>🔍 Smart detection active - technical terms and acronyms will be preserved.</small>'
                }
                </div>
                
                <div class="normalization-controls">
                    <div class="select-all-container">
                        <input type="checkbox" id="selectAllNormalization" onchange="toggleSelectAll()" checked>
                        <label for="selectAllNormalization">Select All</label>
                    </div>
                    <div class="selection-summary" id="selectionSummary">
                        ${selectedCorrections.size} of ${corrections.length} changes selected
                    </div>
                </div>
            `;

            corrections.forEach(correction => {
                const isSelected = selectedCorrections.has(correction.id);
                const hasPreservedTerms = correction.preservedTerms && correction.preservedTerms.length > 0;

                html += `
                    <div class="normalization-item ${isSelected ? 'selected' : 'unselected'}" id="item_${correction.id}">
                        <input type="checkbox" class="normalization-checkbox" 
                               id="${correction.id}" 
                               onchange="toggleCorrection('${correction.id}')"
                               ${isSelected ? 'checked' : ''}>
                        <div class="normalization-before">${correction.original}</div>
                        <div class="normalization-arrow">→</div>
                        <div class="normalization-after">${correction.normalized}</div>
                        ${hasPreservedTerms ?
                        `<div class="preserved-terms">🛡️ ${correction.preservedTerms.join(', ')}</div>` :
                        ''
                    }
                    </div>
                `;
            });

            content.innerHTML = html;
            updateConfirmButtonState();
        }

        function closeNormalizationPanel() {
            document.getElementById('normalizationPanel').style.display = 'none';
            normalizationCorrections = [];
            selectedCorrections.clear();
        }

        function toggleCorrection(correctionId) {
            if (selectedCorrections.has(correctionId)) {
                selectedCorrections.delete(correctionId);
            } else {
                selectedCorrections.add(correctionId);
            }

            // Update visual state
            const itemElement = document.getElementById(`item_${correctionId}`);
            const checkbox = document.getElementById(correctionId);

            if (selectedCorrections.has(correctionId)) {
                itemElement.classList.add('selected');
                itemElement.classList.remove('unselected');
            } else {
                itemElement.classList.remove('selected');
                itemElement.classList.add('unselected');
            }

            updateSelectionSummary();
            updateSelectAllCheckbox();
            updateConfirmButtonState();
        }

        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAllNormalization');
            const isSelectingAll = selectAllCheckbox.checked;

            if (isSelectingAll) {
                // Select all corrections
                normalizationCorrections.forEach(correction => {
                    selectedCorrections.add(correction.id);
                });
            } else {
                // Deselect all corrections
                selectedCorrections.clear();
            }

            // Update all checkboxes and visual states
            normalizationCorrections.forEach(correction => {
                const checkbox = document.getElementById(correction.id);
                const itemElement = document.getElementById(`item_${correction.id}`);

                if (checkbox) {
                    checkbox.checked = isSelectingAll;

                    if (isSelectingAll) {
                        itemElement.classList.add('selected');
                        itemElement.classList.remove('unselected');
                    } else {
                        itemElement.classList.remove('selected');
                        itemElement.classList.add('unselected');
                    }
                }
            });

            updateSelectionSummary();
            updateConfirmButtonState();
        }

        function updateSelectAllCheckbox() {
            const selectAllCheckbox = document.getElementById('selectAllNormalization');
            if (selectAllCheckbox) {
                const totalCorrections = normalizationCorrections.length;
                const selectedCount = selectedCorrections.size;

                if (selectedCount === 0) {
                    selectAllCheckbox.checked = false;
                    selectAllCheckbox.indeterminate = false;
                } else if (selectedCount === totalCorrections) {
                    selectAllCheckbox.checked = true;
                    selectAllCheckbox.indeterminate = false;
                } else {
                    selectAllCheckbox.checked = false;
                    selectAllCheckbox.indeterminate = true;
                }
            }
        }

        function updateSelectionSummary() {
            const summaryElement = document.getElementById('selectionSummary');
            if (summaryElement) {
                summaryElement.textContent = `${selectedCorrections.size} of ${normalizationCorrections.length} changes selected`;
            }
        }

        function updateConfirmButtonState() {
            const confirmButton = document.querySelector('.normalization-panel-footer .btn.primary');
            if (confirmButton) {
                confirmButton.disabled = selectedCorrections.size === 0;
                confirmButton.textContent = selectedCorrections.size === 0 ?
                    '✅ No Changes Selected' :
                    `✅ Confirm ${selectedCorrections.size} Changes`;
            }
        }

        function applyNormalization() {
            if (selectedCorrections.size === 0) {
                showConfirmationModal(
                    'No Changes Selected',
                    'Please select at least one correction to apply.',
                    function () { }
                );
                return;
            }

            let appliedCount = 0;

            // Only apply selected corrections
            normalizationCorrections.forEach(correction => {
                if (selectedCorrections.has(correction.id)) {
                    const node = correction.node;
                    node.name = correction.normalized;
                    node.renamed = true; // Mark as edited
                    appliedCount++;

                    // Update the visual element if it exists
                    const nodeElement = document.querySelector(`[data-id="${node.id}"] .node-label-main`);
                    if (nodeElement) {
                        nodeElement.textContent = correction.normalized;
                    }

                    // Add renamed class to parent node element
                    const parentNodeElement = document.querySelector(`[data-id="${node.id}"]`);
                    if (parentNodeElement) {
                        parentNodeElement.classList.add('node-renamed');
                    }
                }
            });

            // Trigger auto-save
            scheduleAutoSave();

            // Update performance info
            updatePerformanceInfo(`Normalized ${appliedCount} node labels to Proper Case`);

            // Close panel and show success
            closeNormalizationPanel();

            const skippedCount = normalizationCorrections.length - appliedCount;
            const message = skippedCount > 0 ?
                `Successfully normalized ${appliedCount} node labels to Proper Case.\n${skippedCount} corrections were skipped.\n\nNormalized nodes are marked with edit indicators and changes will be included in your CSV export.` :
                `Successfully normalized ${appliedCount} node labels to Proper Case.\n\nNormalized nodes are marked with edit indicators and changes will be included in your CSV export.`;

            showConfirmationModal(
                'Normalization Complete',
                message,
                function () {
                    // Re-render tree to show updated labels and indicators
                    renderTree();
                }
            );
        }

        // Merge functionality - Simplified Implementation
        let activeMerges = new Map(); // groupKey -> { selectedDestination, sourceNodes, hasSelection }

        function startMerge(groupKey) {
            console.log('startMerge called with groupKey:', groupKey);

            const group = duplicateGroups.get(groupKey);
            console.log('found group:', group);

            if (!group) {
                console.log('Group not found:', groupKey);
                alert('Group not found: ' + groupKey);
                return;
            }

            // Check if there are at least 2 leaf nodes to merge
            const leafNodes = group.nodes.filter(node => isLeafNode(node));
            console.log('leafNodes count:', leafNodes.length);

            if (leafNodes.length < 2) {
                alert('Cannot merge this group: Need at least 2 leaf nodes (nodes without children) to merge.');
                return;
            }

            // Initialize merge for this group
            console.log('Setting up merge for groupKey:', groupKey);
            activeMerges.set(groupKey, {
                selectedDestination: null,
                sourceNodes: [],
                hasSelection: false
            });

            console.log('activeMerges after setup:', activeMerges);
            updateDuplicatePanel();
            updatePerformanceInfo(`Started merge setup for "${group.nodeName}" (${leafNodes.length} leaf nodes available)`);
        }

        function isLeafNode(node) {
            return !node.children || node.children.length === 0;
        }

        function canGroupBeMerged(group) {
            // Check if all nodes in the group are leaf nodes
            return group.nodes.every(node => isLeafNode(node));
        }

        function getMergeStatusForGroup(group, groupKey) {
            const activeMerge = activeMerges.get(groupKey);

            if (!activeMerge) {
                return {
                    hasPendingMerge: false,
                    hasSelection: false,
                    selectedDestination: null,
                    sourceNodes: []
                };
            }

            return {
                hasPendingMerge: true,
                hasSelection: activeMerge.hasSelection,
                selectedDestination: activeMerge.selectedDestination,
                sourceNodes: activeMerge.sourceNodes
            };
        }

        function cancelMerge(groupKey) {
            activeMerges.delete(groupKey);
            updateDuplicatePanel();
            updatePerformanceInfo('Merge cancelled');
        }

        function selectMergeDestination(groupKey, destinationNodeId) {
            const merge = activeMerges.get(groupKey);
            const group = duplicateGroups.get(groupKey);

            if (!merge || !group) {
                console.log('Error: merge or group not found', { groupKey, merge, group });
                alert('Error: Could not find merge data. Please try again.');
                return;
            }

            // Find the destination node and verify it's a leaf node
            const destinationNode = group.nodes.find(node => node.id === destinationNodeId);
            if (!destinationNode || !isLeafNode(destinationNode)) {
                alert('Selected node is not a leaf node and cannot be used as merge destination.');
                return;
            }

            // Set the destination and calculate source nodes
            merge.selectedDestination = destinationNodeId;
            merge.sourceNodes = group.nodes
                .filter(node => node.id !== destinationNodeId && isLeafNode(node))
                .map(node => node.id);
            merge.hasSelection = true;

            // Update the merge in the map
            activeMerges.set(groupKey, merge);

            // Refresh the UI
            updateDuplicatePanel();
            updatePerformanceInfo(`Selected node ${destinationNodeId} as merge destination`);
        }

        function confirmMerge(groupKey) {
            const merge = activeMerges.get(groupKey);
            const group = duplicateGroups.get(groupKey);

            if (!merge || !group || !merge.selectedDestination) {
                alert('Please select a destination node first.');
                return;
            }

            // Apply merge to the data
            merge.sourceNodes.forEach(sourceNodeId => {
                const sourceNode = flatNodesMap.get(sourceNodeId);
                if (sourceNode) {
                    sourceNode.mergeTarget = merge.selectedDestination;
                }
            });

            // Clean up
            activeMerges.delete(groupKey);

            // Trigger auto-save
            scheduleAutoSave();

            // Update UI
            updateDuplicatePanel();
            updateMergeIndicators(merge.sourceNodes, merge.selectedDestination);
            updatePerformanceInfo(`Merged ${merge.sourceNodes.length} nodes to ${merge.selectedDestination}`);

            // Show success message
            showConfirmationModal(
                'Merge Completed',
                `Successfully set up merge for ${merge.sourceNodes.length} duplicate nodes.\n\nThe merge information will be included in your CSV export in the "merge" column.`,
                function () { } // Just close the modal
            );
        }

        function updateMergeIndicators(sourceNodeIds, destinationNodeId) {
            // Update indicators for source nodes that were merged
            sourceNodeIds.forEach(nodeId => {
                const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
                if (nodeElement) {
                    nodeElement.classList.add('node-merged');
                    const mergeIndicator = nodeElement.querySelector('.merge-indicator');
                    if (mergeIndicator) {
                        mergeIndicator.title = `This node will be merged to: ${destinationNodeId}`;
                    }
                }
            });
        }

        function updateAllMergeIndicators() {
            // Update indicators for all nodes that have mergeTarget set
            flatNodesMap.forEach((node, nodeId) => {
                if (node.mergeTarget) {
                    const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
                    if (nodeElement) {
                        nodeElement.classList.add('node-merged');
                        const mergeIndicator = nodeElement.querySelector('.merge-indicator');
                        if (mergeIndicator) {
                            mergeIndicator.title = `This node will be merged to: ${node.mergeTarget}`;
                        }
                    }
                }
            });
        }

        function scrollToNode(nodeId) {
            // First expand the path to the node
            expandPathToNode(nodeId);

            // Wait a bit for the expansion to complete, then scroll
            setTimeout(() => {
                const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
                if (nodeElement) {
                    // Temporarily highlight the target node
                    const nodeContent = nodeElement.querySelector('.node-content');
                    nodeContent.style.transition = 'all 0.3s ease';
                    nodeContent.style.backgroundColor = '#007bff';
                    nodeContent.style.color = 'white';
                    nodeContent.style.transform = 'scale(1.02)';

                    // Scroll to the node
                    nodeElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });

                    // Remove highlight after a delay
                    setTimeout(() => {
                        nodeContent.style.backgroundColor = '';
                        nodeContent.style.color = '';
                        nodeContent.style.transform = '';

                        // Restore duplicate highlighting if it was there
                        if (duplicateDetectionActive) {
                            setTimeout(() => {
                                nodeContent.classList.add('node-duplicate');
                            }, 300);
                        }
                    }, 1500);

                    updatePerformanceInfo(`Navigated to node: ${nodeId}`);
                }
            }, 200);
        }

        window.onclick = function (event) {
            const modal = document.getElementById('helpModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }

        // Performance monitoring
        function updatePerformanceInfo(message) {
            const perfInfo = document.getElementById('performanceInfo');
            const elapsed = Date.now() - loadingStartTime;
            perfInfo.innerHTML = `
                <strong>Status:</strong> ${message} | 
                <strong>Load Time:</strong> ${elapsed}ms | 
                <strong>Memory:</strong> ${(performance.memory?.usedJSHeapSize / 1024 / 1024).toFixed(1) || 'N/A'} MB
            `;
            perfInfo.style.display = 'block';
        }

        // Build flat map for efficient lookups
        function buildFlatNodeMap(nodes) {
            function processNode(node) {
                flatNodesMap.set(node.id, node);
                totalNodes++;
                if (node.children && node.children.length > 0) {
                    node.children.forEach(child => processNode(child));
                }
            }

            totalNodes = 0;
            flatNodesMap.clear();
            nodes.forEach(rootNode => processNode(rootNode));
        }

        // Display statistics
        function displayStats() {
            const stats = calculateStats(nodesData);
            document.getElementById('statsGrid').innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${totalNodes.toLocaleString()}</div>
                    <div>Total Nodes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.rootNodes}</div>
                    <div>Root Categories</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.levels.l1 || 0}</div>
                    <div>Level 1</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.levels.l2 || 0}</div>
                    <div>Level 2</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.levels.l3 || 0}</div>
                    <div>Level 3</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.levels.l4 || 0}</div>
                    <div>Level 4</div>
                </div>
            `;
        }

        function calculateStats(data) {
            const levels = {};

            flatNodesMap.forEach(node => {
                levels[node.level] = (levels[node.level] || 0) + 1;
            });

            return {
                totalNodes: totalNodes,
                rootNodes: data.length,
                levels: levels
            };
        }

        // Render tree with lazy loading
        function renderTree() {
            const treeElement = document.getElementById('tree');
            treeElement.innerHTML = '';
            renderedNodes.clear();

            nodesData.forEach(rootNode => {
                treeElement.appendChild(createNodeElement(rootNode, false));
            });

            // Update merge indicators for all merged nodes
            updateAllMergeIndicators();

            // Re-apply duplicate detection if it was active
            if (duplicateDetectionActive) {
                setTimeout(() => {
                    findAndHighlightDuplicates();
                }, 100);
            }

            updatePerformanceInfo(`Rendered ${nodesData.length} root nodes`);
        }

        function createNodeElement(node, isExpanded = false) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = `node level-${node.level}`;
            nodeDiv.setAttribute('data-id', node.id);

            const hasChildren = node.children && node.children.length > 0;

            const nodeContent = document.createElement('div');
            nodeContent.className = 'node-content';
            nodeContent.onclick = () => toggleNode(node.id);

            const toggleBtn = document.createElement('button');
            toggleBtn.className = `toggle-btn ${hasChildren ? '' : 'no-children'}`;
            toggleBtn.innerHTML = hasChildren ? (isExpanded ? '−' : '+') : '●';

            const label = document.createElement('span');
            label.className = 'node-label editable';

            // Create main name element
            const mainName = document.createElement('span');
            mainName.className = 'node-label-main';
            mainName.textContent = node.name;
            label.appendChild(mainName);

            // Add German translation if available
            if (node.german && node.german.trim()) {
                const separator = document.createElement('span');
                separator.className = 'node-label-separator';
                separator.textContent = '|';
                label.appendChild(separator);

                const germanName = document.createElement('span');
                germanName.className = 'node-label-german';
                germanName.textContent = node.german;
                label.appendChild(germanName);
            }

            label.onclick = (e) => {
                e.stopPropagation();
                makeNodeEditable(nodeDiv, node);
            };

            const editIndicator = document.createElement('span');
            editIndicator.className = 'edit-indicator';
            editIndicator.textContent = '✏️';

            const mergeIndicator = document.createElement('span');
            mergeIndicator.className = 'merge-indicator';
            mergeIndicator.textContent = '⚡';
            mergeIndicator.title = 'This node has been merged';

            const info = document.createElement('span');
            info.className = 'node-info';
            info.textContent = `${node.level} | ID: ${node.id}`;
            if (hasChildren) {
                info.textContent += ` | ${node.children.length} children`;
            }

            nodeContent.appendChild(toggleBtn);
            nodeContent.appendChild(label);
            nodeContent.appendChild(editIndicator);
            nodeContent.appendChild(mergeIndicator);

            // Add renamed indicator if node was renamed
            if (node.renamed) {
                const renamedIndicator = document.createElement('span');
                renamedIndicator.className = 'renamed-indicator';
                renamedIndicator.textContent = '✏️';
                renamedIndicator.title = 'This node has been renamed';
                nodeContent.appendChild(renamedIndicator);
                nodeDiv.classList.add('node-renamed');
            }

            // Add German changed indicator if German translation was modified
            if (node.german_changed) {
                const germanChangedIndicator = document.createElement('span');
                germanChangedIndicator.className = 'german-changed-indicator';
                germanChangedIndicator.textContent = 'DE';
                germanChangedIndicator.title = 'German translation has been modified';
                nodeContent.appendChild(germanChangedIndicator);
            }

            // Add merge indicator if node has been merged
            if (node.mergeTarget) {
                nodeDiv.classList.add('node-merged');
                mergeIndicator.title = `This node will be merged to: ${node.mergeTarget}`;
            }

            nodeContent.appendChild(info);
            nodeDiv.appendChild(nodeContent);

            if (hasChildren && isExpanded) {
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'children expanded';

                node.children.forEach(child => {
                    childrenDiv.appendChild(createNodeElement(child, false));
                });

                nodeDiv.appendChild(childrenDiv);
            } else if (hasChildren) {
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'children collapsed';
                nodeDiv.appendChild(childrenDiv);
            }

            renderedNodes.add(node.id);
            return nodeDiv;
        }

        function toggleNode(nodeId) {
            const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
            if (!nodeElement) return;

            const node = flatNodesMap.get(nodeId);
            if (!node || !node.children || node.children.length === 0) return;

            const childrenDiv = nodeElement.querySelector('.children');
            const toggleBtn = nodeElement.querySelector('.toggle-btn');
            const isExpanded = childrenDiv.classList.contains('expanded');

            if (isExpanded) {
                childrenDiv.classList.remove('expanded');
                childrenDiv.classList.add('collapsed');
                toggleBtn.innerHTML = '+';
            } else {
                if (childrenDiv.children.length === 0) {
                    node.children.forEach(child => {
                        childrenDiv.appendChild(createNodeElement(child, false));
                    });
                }

                childrenDiv.classList.remove('collapsed');
                childrenDiv.classList.add('expanded');
                toggleBtn.innerHTML = '−';
            }
        }

        function expandLevel(maxLevel) {
            collapseAll();

            document.querySelectorAll('.node').forEach(nodeElement => {
                const nodeId = nodeElement.getAttribute('data-id');
                const node = flatNodesMap.get(nodeId);
                if (node) {
                    const level = parseInt(node.level.substring(1));
                    if (level < maxLevel && node.children && node.children.length > 0) {
                        toggleNode(nodeId);
                    }
                }
            });

            updatePerformanceInfo(`Expanded to level ${maxLevel}`);
        }

        function collapseAll() {
            document.querySelectorAll('.children.expanded').forEach(childrenDiv => {
                const nodeElement = childrenDiv.closest('.node');
                const nodeId = nodeElement.getAttribute('data-id');
                const toggleBtn = nodeElement.querySelector('.toggle-btn');

                childrenDiv.classList.remove('expanded');
                childrenDiv.classList.add('collapsed');
                toggleBtn.innerHTML = '+';
            });

            updatePerformanceInfo('Collapsed all nodes');
        }

        function searchNodes() {
            const searchInput = document.getElementById('searchInput');
            searchTerm = searchInput.value.toLowerCase().trim();

            // Clear previous search results and arrows
            document.querySelectorAll('.node-content.highlighted').forEach(element => {
                element.classList.remove('highlighted');
            });
            clearSearchArrows();

            if (searchTerm === '') return;

            let matchCount = 0;
            const startTime = Date.now();
            const matchingNodes = [];

            flatNodesMap.forEach((node, nodeId) => {
                const englishMatch = node.name.toLowerCase().includes(searchTerm);
                const germanMatch = node.german && node.german.toLowerCase().includes(searchTerm);

                if (englishMatch || germanMatch) {
                    matchCount++;
                    expandPathToNode(nodeId);

                    const nodeElement = document.querySelector(`[data-id="${nodeId}"] .node-content`);
                    if (nodeElement) {
                        nodeElement.classList.add('highlighted');
                        matchingNodes.push(nodeElement);
                    }
                }
            });

            const searchTime = Date.now() - startTime;
            updatePerformanceInfo(`Found ${matchCount} matches in ${searchTime}ms`);

            // Add arrow indicators for all matching nodes
            setTimeout(() => {
                addSearchArrows(matchingNodes);

                const firstMatch = document.querySelector('.node-content.highlighted');
                if (firstMatch) {
                    firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }

        function expandPathToNode(nodeId) {
            const path = [];
            let currentNode = flatNodesMap.get(nodeId);

            while (currentNode && currentNode.pid) {
                path.unshift(currentNode.pid);
                currentNode = flatNodesMap.get(currentNode.pid);
            }

            path.forEach(id => {
                const nodeElement = document.querySelector(`[data-id="${id}"]`);
                if (nodeElement) {
                    const childrenDiv = nodeElement.querySelector('.children');
                    if (childrenDiv && childrenDiv.classList.contains('collapsed')) {
                        toggleNode(id);
                    }
                }
            });
        }

        function addSearchArrows(matchingNodes) {
            clearSearchArrows(); // Clear any existing arrows first

            matchingNodes.forEach((nodeElement, index) => {
                const rect = nodeElement.getBoundingClientRect();
                const arrow = document.createElement('div');
                arrow.className = 'search-arrow';
                arrow.style.top = (rect.top + rect.height / 2 - 12) + 'px'; // Center arrow with node
                arrow.setAttribute('data-node-id', nodeElement.closest('[data-id]').getAttribute('data-id'));

                // Add a slight delay for each arrow to create a staggered animation effect
                arrow.style.animationDelay = (index * 0.2) + 's';

                document.body.appendChild(arrow);
            });

            // Update arrow positions on scroll
            updateArrowPositions();
        }

        function updateArrowPositions() {
            const arrows = document.querySelectorAll('.search-arrow');
            arrows.forEach(arrow => {
                const nodeId = arrow.getAttribute('data-node-id');
                const nodeElement = document.querySelector(`[data-id="${nodeId}"] .node-content`);
                if (nodeElement) {
                    const rect = nodeElement.getBoundingClientRect();
                    // Only show arrow if node is visible on screen
                    if (rect.top >= 0 && rect.bottom <= window.innerHeight) {
                        arrow.style.top = (rect.top + rect.height / 2 - 12) + 'px';
                        arrow.style.display = 'block';
                    } else {
                        arrow.style.display = 'none'; // Hide arrows for off-screen nodes
                    }
                }
            });
        }

        function clearSearchArrows() {
            document.querySelectorAll('.search-arrow').forEach(arrow => {
                arrow.remove();
            });
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            searchTerm = '';
            document.querySelectorAll('.node-content.highlighted').forEach(element => {
                element.classList.remove('highlighted');
            });
            clearSearchArrows(); // Clear arrows when clearing search
            updatePerformanceInfo('Search cleared');
        }

        // Try to load default data on startup
        document.addEventListener('DOMContentLoaded', async function () {
            // Don't load default data - force user to import CSV
            console.log('Interactive Organigram loaded - please import a CSV file to begin');
            updatePerformanceInfo('Ready - Please import a CSV file to get started');
            updateToolbarState(false); // Disable data-dependent buttons
        });

        // Update toolbar button states based on whether data is loaded
        function updateToolbarState(hasData) {
            const buttons = ['clearBtn', 'exportBtn', 'normalizeBtn', 'editBtn', 'duplicateBtn', 'clearSearchBtn'];
            const navLinks = ['expandL1Nav', 'expandL2Nav', 'expandL3Nav', 'collapseAllNav'];
            const searchInput = document.getElementById('searchInput');
            const bottomToolbar = document.getElementById('bottomToolbar');

            // Handle regular buttons
            buttons.forEach(buttonId => {
                const button = document.getElementById(buttonId);
                if (button) {
                    button.disabled = !hasData;
                }
            });

            // Handle navigation links
            navLinks.forEach(linkId => {
                const link = document.getElementById(linkId);
                if (link) {
                    if (hasData) {
                        link.classList.remove('disabled');
                    } else {
                        link.classList.add('disabled');
                    }
                }
            });

            // Show/hide bottom toolbar based on data availability
            if (bottomToolbar) {
                bottomToolbar.style.display = hasData ? 'flex' : 'none';
            }

            if (searchInput) {
                searchInput.disabled = !hasData;
                if (!hasData) {
                    searchInput.value = '';
                    searchInput.placeholder = 'Import data to enable search...';
                } else {
                    searchInput.placeholder = 'Search nodes (English/German) - Press Enter to search...';
                }
            }
        }

        // Search functionality
        function handleSearchKeypress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                searchNodes();
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function (event) {
            if (event.ctrlKey || event.metaKey) {
                switch (event.key) {
                    case 'f':
                        event.preventDefault();
                        document.getElementById('searchInput').focus();
                        break;
                    case 'c':
                        event.preventDefault();
                        collapseAll();
                        break;
                }
            }
            if (event.key === 'Escape') {
                clearSearch();
                closeConfirmationModal();
            }
        });

        // Confirmation Modal System
        let confirmationCallback = null;
        let hasUnsavedChanges = false;

        function showConfirmationModal(title, message, onConfirm) {
            const modal = document.getElementById('confirmationModal');
            const titleElement = document.getElementById('confirmationTitle');
            const messageElement = document.getElementById('confirmationMessage');

            titleElement.textContent = title;
            messageElement.textContent = message;
            confirmationCallback = onConfirm;

            modal.style.display = 'flex';
        }

        function closeConfirmationModal() {
            const modal = document.getElementById('confirmationModal');
            modal.style.display = 'none';
            confirmationCallback = null;
        }

        function confirmAction() {
            if (confirmationCallback) {
                confirmationCallback();
            }
            closeConfirmationModal();
        }

        // Track unsaved changes
        function setUnsavedChanges(hasChanges) {
            hasUnsavedChanges = hasChanges;
        }

        // Enhanced clear data function with confirmation
        function clearDataWithConfirmation() {
            if (nodesData.length === 0) {
                alert('No data to clear.');
                return;
            }

            const modificationStats = getModificationStats();
            let message = 'This will permanently delete all loaded data and clear the organigram.';

            if (modificationStats.totalModifications > 0) {
                message += `\n\nYou have ${modificationStats.totalModifications} unsaved modification(s) that will be lost.`;
            }

            message += '\n\nThis action cannot be undone. Are you sure?';

            showConfirmationModal(
                'Clear All Data',
                message,
                function () {
                    // Clear session data and refresh the page for a fresh start
                    clearSession();
                    localStorage.removeItem('organigram_session');

                    // Refresh the page to start completely fresh
                    window.location.reload();
                }
            );
        }

        // Page unload warning
        window.addEventListener('beforeunload', function (event) {
            if (hasUnsavedChanges || (sessionData.modifiedNodes && sessionData.modifiedNodes.size > 0)) {
                const message = 'You have unsaved changes. Are you sure you want to leave?';
                event.preventDefault();
                event.returnValue = message;
                return message;
            }
        });

        // Update search arrow positions on scroll
        let scrollTimeout;
        window.addEventListener('scroll', function () {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(updateArrowPositions, 16); // Throttle to ~60fps
        });

        // Modal event listeners
        document.addEventListener('DOMContentLoaded', function () {
            const confirmBtn = document.getElementById('confirmationConfirm');
            const cancelBtn = document.getElementById('confirmationCancel');
            const modal = document.getElementById('confirmationModal');

            if (confirmBtn) {
                confirmBtn.addEventListener('click', confirmAction);
            }

            if (cancelBtn) {
                cancelBtn.addEventListener('click', closeConfirmationModal);
            }

            // Close modal when clicking outside
            if (modal) {
                modal.addEventListener('click', function (event) {
                    if (event.target === modal) {
                        closeConfirmationModal();
                    }
                });
            }
        });
    </script>

    <!-- Floating Help Button -->
    <button class="floating-help" onclick="showHelpModal()" title="Help & Documentation">
        ❓
    </button>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="confirmation-modal">
        <div class="confirmation-content">
            <div class="confirmation-title">
                <span>⚠️</span>
                <span id="confirmationTitle">Confirm Action</span>
            </div>
            <div id="confirmationMessage" class="confirmation-message">
                Are you sure you want to proceed?
            </div>
            <div class="confirmation-buttons">
                <button id="confirmationCancel" class="confirmation-btn secondary">Cancel</button>
                <button id="confirmationConfirm" class="confirmation-btn danger">Confirm</button>
            </div>
        </div>
    </div>
</body>

</html>