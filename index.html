<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Organigram with Import</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding-top: 80px; /* Space for fixed toolbar only */
            margin: 0;
        }

        .toolbar {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 99;
            border-bottom: 1px solid #e9ecef;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            margin: 0;
        }

        .toolbar-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            justify-content: flex-start;
        }

        .toolbar-section:last-child {
            margin-bottom: 0;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid #cccccc;
            border-radius: 4px;
            background: #ffffff;
            color: #333333;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #f5f5f5;
            border-color: #999999;
        }

        .btn:disabled {
            background: #f8f8f8;
            color: #cccccc;
            cursor: not-allowed;
            border-color: #e0e0e0;
        }

        .btn.primary {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .btn.primary:hover {
            background: #0056b3;
            border-color: #004085;
        }

        .search-input {
            padding: 10px 15px;
            border: 1px solid #cccccc;
            border-radius: 4px;
            font-size: 14px;
            width: 350px;
            transition: all 0.3s;
        }

        .search-input:focus {
            outline: none;
            border-color: #999999;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
        }

        .import-section {
            background: white;
            margin: 20px;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 2px dashed #cccccc;
            text-align: center;
            transition: all 0.3s;
        }

        .import-section.dragover {
            border-color: #007bff;
            background: #f8f9fa;
        }

        .import-section.hidden {
            display: none;
        }

        .import-section.minimized {
            padding: 10px 20px;
            margin: 10px 20px;
            border: 1px solid #e0e0e0;
            border-style: solid;
        }

        .import-section.minimized .file-drop-area {
            padding: 20px;
        }

        .file-input {
            display: none;
        }

        .file-drop-area {
            padding: 40px;
            cursor: pointer;
        }

        .file-drop-area:hover {
            background: #f8f9fa;
        }

        .import-progress {
            margin: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: #007bff;
            width: 0%;
            transition: width 0.3s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            text-align: center;
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            color: #333333;
            margin-bottom: 10px;
        }

        .tree-container {
            background: white;
            margin: 20px;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
            min-height: 70vh;
        }

        .tree {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            font-size: 13px;
        }

        .node {
            margin: 1px 0;
            position: relative;
        }

        .node-content {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.3s ease;
            cursor: pointer;
            border: 2px solid transparent;
            min-width: 0; /* Allow flex items to shrink */
        }

        .node-content:hover {
            background-color: #f5f5f5;
            transform: translateX(2px);
            border-color: #cccccc;
        }

        .node-content.highlighted {
            background: #fff3e0 !important;
            border: 3px solid #ff6b35 !important;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.3) !important;
            transform: scale(1.02);
            transition: all 0.3s ease;
        }

        .toggle-btn {
            width: 20px;
            height: 20px;
            border: 1px solid #cccccc;
            background: #ffffff;
            color: #333333;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            font-weight: bold;
        }

        .toggle-btn:hover {
            background: #f5f5f5;
            border-color: #999999;
        }

        .toggle-btn.no-children {
            background: #f8f8f8;
            color: #cccccc;
            cursor: default;
            border-color: #e0e0e0;
        }

        .node-label {
            flex: 1;
            font-weight: 500;
            margin-right: 8px;
            font-size: 13px;
            line-height: 1.3;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .node-label-main {
            font-weight: 500;
            font-size: 13px;
        }

        .node-label-separator {
            color: #999;
            font-weight: normal;
            font-size: 12px;
        }

        .node-label-german {
            font-size: 12px;
            color: #666;
            font-weight: 400;
            font-style: italic;
        }

        .german-indicator {
            color: #6c757d;
            font-size: 9px;
            margin-left: 2px;
            padding: 1px 3px;
            background: #f8f9fa;
            border-radius: 2px;
            border: 1px solid #dee2e6;
        }

        .node-label.editable {
            cursor: text;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .node-label.editable:hover {
            background-color: #f0f0f0;
        }

        .node-label input {
            border: none;
            background: transparent;
            font: inherit;
            color: inherit;
            width: 100%;
            outline: none;
        }

        .edit-indicator {
            display: none;
            color: #999;
            font-size: 10px;
            margin-left: 4px;
        }

        .edit-mode .edit-indicator {
            display: inline;
        }

        .edit-mode .node-label.editable {
            background-color: #f8f8f8;
            border: 1px dashed #ccc;
        }

        .node-duplicate {
            background-color: #fff3cd !important;
            border-color: #ffc107 !important;
            position: relative;
        }

        .node-duplicate::before {
            content: "‚ö†Ô∏è";
            position: absolute;
            right: 4px;
            top: 4px;
            font-size: 10px;
            color: #856404;
        }

        .node-renamed {
            background-color: #e8f5e8 !important;
            border-color: #28a745 !important;
            position: relative;
        }

        .renamed-indicator {
            color: #28a745;
            font-size: 10px;
            margin-left: 4px;
            padding: 1px 3px;
            background: #d4edda;
            border-radius: 2px;
            border: 1px solid #c3e6cb;
        }

        .german-changed-indicator {
            color: #007bff;
            font-size: 10px;
            margin-left: 4px;
            padding: 1px 3px;
            background: #d1ecf1;
            border-radius: 2px;
            border: 1px solid #bee5eb;
        }

        /* Confirmation Modal Styles */
        .confirmation-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .confirmation-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        .confirmation-title {
            font-size: 20px;
            font-weight: bold;
            color: #dc3545;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .confirmation-message {
            font-size: 16px;
            margin-bottom: 25px;
            line-height: 1.5;
            color: #333;
        }

        .confirmation-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .confirmation-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .confirmation-btn.danger {
            background: #dc3545;
            color: white;
        }

        .confirmation-btn.danger:hover {
            background: #c82333;
        }

        .confirmation-btn.secondary {
            background: #6c757d;
            color: white;
        }

        .confirmation-btn.secondary:hover {
            background: #5a6268;
        }

        /* Floating Help Button */
        .floating-help {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .floating-help:hover {
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 123, 255, 0.4);
        }

        .floating-help:active {
            transform: translateY(0);
        }

        /* Search Arrow Indicators */
        .search-arrow {
            position: fixed;
            right: 10px;
            width: 0;
            height: 0;
            border-top: 12px solid transparent;
            border-bottom: 12px solid transparent;
            border-right: 20px solid #ff6b35;
            z-index: 500;
            animation: searchPulse 1.5s ease-in-out infinite;
            filter: drop-shadow(-2px 0 4px rgba(255, 107, 53, 0.3));
        }

        @keyframes searchPulse {
            0%, 100% {
                opacity: 0.8;
                transform: translateX(0);
            }
            50% {
                opacity: 1;
                transform: translateX(-5px);
            }
        }

        .auto-save-indicator {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 10px;
            transition: all 0.3s;
        }

        .auto-save-indicator.saving {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .auto-save-indicator.saved {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .auto-save-indicator.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .duplicate-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 400px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            border: 1px solid #e0e0e0;
            z-index: 200;
            display: none;
        }

        .duplicate-panel-header {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .duplicate-panel-header h3 {
            margin: 0;
            font-size: 14px;
            color: #333;
        }

        .duplicate-panel-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .duplicate-panel-close:hover {
            color: #333;
        }

        .duplicate-panel-content {
            max-height: 320px;
            overflow-y: auto;
            padding: 10px;
        }

        .duplicate-group {
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background: #f8f9fa;
        }

        .duplicate-group-header {
            padding: 8px 12px;
            background: #e9ecef;
            font-weight: 600;
            font-size: 12px;
            color: #495057;
            border-bottom: 1px solid #dee2e6;
        }

        .duplicate-item {
            padding: 8px 12px;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        .duplicate-item:last-child {
            border-bottom: none;
        }

        .duplicate-item:hover {
            background-color: #e9ecef;
        }

        .duplicate-item-name {
            font-weight: 500;
            color: #333;
        }

        .duplicate-item-path {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }

        .node-info {
            font-size: 10px;
            padding: 1px 6px;
            border-radius: 3px;
            background: #f5f5f5;
            color: #666666;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .children {
            margin-left: 28px;
            border-left: 1px solid #e0e0e0;
            padding-left: 16px;
            overflow: hidden;
            transition: all 0.4s ease;
        }

        .children.collapsed {
            max-height: 0;
            padding: 0;
            margin: 0;
            border: none;
        }

        .children.expanded {
            max-height: none;
        }

        .level-l1 .node-content {
            background: #f8f8f8;
            color: #333333;
            font-weight: bold;
            font-size: 14px;
            border: 2px solid #cccccc;
            padding: 8px 12px;
        }

        .level-l2 .node-content {
            background: #f5f5f5;
            color: #333333;
            font-weight: 600;
            border: 1px solid #d0d0d0;
            font-size: 13px;
        }

        .level-l3 .node-content {
            background: #f9f9f9;
            color: #333333;
            border: 1px solid #e0e0e0;
            font-size: 12px;
        }

        .level-l4 .node-content {
            background: #ffffff;
            color: #666666;
            border: 1px solid #e5e5e5;
            font-size: 12px;
        }

        .loading {
            text-align: center;
            padding: 60px;
            font-size: 18px;
            color: #6c757d;
        }

        .error {
            text-align: center;
            padding: 60px;
            color: #d32f2f;
            background: #ffffff;
            border-radius: 8px;
            margin: 20px;
            border: 1px solid #e0e0e0;
        }

        .performance-info {
            background: #f8f8f8;
            color: #333333;
            padding: 10px 20px;
            margin: 20px;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
            font-size: 14px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
            max-height: 80%;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #999;
        }

        .close:hover {
            color: #333;
        }

        @media (max-width: 768px) {
            .search-input {
                width: 100%;
                max-width: 300px;
            }
            
            body {
                padding-top: 120px; /* More space for wrapped toolbar on mobile */
            }
            
            .toolbar {
                padding: 10px 15px;
            }
            
            .toolbar-section {
                gap: 8px;
            }
            
            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>


    <div class="toolbar">
        <div class="toolbar-section">
            <button class="btn primary" onclick="showImportSection()">üìÅ Import CSV File</button>
            <button class="btn" onclick="clearDataWithConfirmation()" id="clearBtn" disabled>üóëÔ∏è Clear Data</button>
            <button class="btn" onclick="exportToCSV()" id="exportBtn" disabled>üíæ Export CSV</button>
            <button class="btn" onclick="toggleEditMode()" id="editBtn" disabled>‚úèÔ∏è Edit Mode</button>
            <button class="btn" onclick="toggleDuplicateDetection()" id="duplicateBtn" disabled>üîç Find Duplicates</button>
            <button class="btn" onclick="expandLevel(1)" id="expandL1" disabled>Show L1</button>
            <button class="btn" onclick="expandLevel(2)" id="expandL2" disabled>Show L1-2</button>
            <button class="btn" onclick="collapseAll()" id="collapseBtn" disabled>Collapse All</button>
            <input type="text" class="search-input" id="searchInput" placeholder="Search nodes (English/German) - Press Enter to search..." onkeypress="handleSearchKeypress(event)" disabled>
            <button class="btn" onclick="clearSearch()" id="clearSearchBtn" disabled>Clear</button>
            <span id="autoSaveIndicator" class="auto-save-indicator"></span>
        </div>
    </div>

    <div class="import-section" id="importSection">
        <div class="file-drop-area" onclick="triggerFileInput()">
            <h3>üìÅ Import Your Data</h3>
            <p>Click here or drag & drop your CSV or Excel file to get started</p>
            <p><small>Required columns: name, id, pid, level | Optional: name_de, renamed, german_changed</small></p>
            <input type="file" id="fileInput" class="file-input" accept=".csv,.xlsx,.xls" onchange="handleFileSelect(event)">
        </div>
        <div style="text-align: center; margin-top: 15px;">
            <button class="btn" onclick="showHelpModal()" style="margin-right: 10px;">‚ùì Need Help?</button>
            <button class="btn" onclick="downloadSample()">üì• Download Sample CSV</button>
        </div>
    </div>

    <div class="import-progress" id="importProgress">
        <h4>Processing File...</h4>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div id="progressText">Starting import...</div>
    </div>

    <div class="performance-info" id="performanceInfo" style="display: none;">
        <!-- Performance metrics will be shown here -->
    </div>

    <div class="stats-grid" id="statsGrid">
        <!-- Stats will be populated by JavaScript -->
    </div>

    <div class="tree-container">
        <div id="loading" class="loading">
            <h3>üå≥ Welcome to Interactive Organigram</h3>
            <p>Import a CSV file above to visualize your hierarchical data with powerful features:</p>
            <ul style="text-align: left; display: inline-block; margin-top: 20px;">
                <li>üìÅ <strong>CSV Import/Export</strong> - Drag & drop or browse files</li>
                <li>‚úèÔ∏è <strong>Inline Editing</strong> - Click any node name to edit</li>
                <li>üîç <strong>Duplicate Detection</strong> - Find and navigate duplicates</li>
                <li>üéØ <strong>Interactive Navigation</strong> - Expand/collapse hierarchy</li>
                <li>üì± <strong>Mobile Responsive</strong> - Works on all devices</li>
            </ul>
            <p style="margin-top: 20px;"><strong>Get started by importing your CSV file above!</strong></p>
        </div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="tree" class="tree" style="display: none;"></div>
    </div>

    <!-- Duplicate Detection Panel -->
    <div id="duplicatePanel" class="duplicate-panel">
        <div class="duplicate-panel-header">
            <h3>üîç Duplicate Nodes</h3>
            <button class="duplicate-panel-close" onclick="closeDuplicatePanel()">√ó</button>
        </div>
        <div class="duplicate-panel-content" id="duplicateContent">
            <!-- Duplicate groups will be populated here -->
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üìã File Format Requirements</h3>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <div>
                <h4>Required Columns:</h4>
                <ul>
                    <li><strong>name</strong> - Node name/description (English)</li>
                    <li><strong>id</strong> - Unique identifier</li>
                    <li><strong>pid</strong> - Parent ID (NULL/empty for root nodes)</li>
                    <li><strong>level</strong> - Hierarchical level (l1, l2, l3, l4)</li>
                </ul>
                
                <h4>Optional Columns:</h4>
                <ul>
                    <li><strong>name_de</strong> - German translation of the node name</li>
                    <li><strong>renamed</strong> - TRUE/FALSE flag for edited English names</li>
                    <li><strong>german_changed</strong> - TRUE/FALSE flag for modified German translations</li>
                </ul>
                
                <h4>Example CSV:</h4>
                <pre>name,id,pid,level,name_de,german_changed
"Company","1",NULL,"l1","Unternehmen","FALSE"
"Engineering","2","1","l2","Entwicklung","FALSE"
"Frontend Team","3","2","l3","Frontend-Team","FALSE"
"John Doe","4","3","l4","Hans M√ºller","FALSE"</pre>
                
                <h4>Editing Features:</h4>
                <ul>
                    <li><strong>Edit Mode</strong> - Click "‚úèÔ∏è Edit Mode" to enable label editing</li>
                    <li><strong>Click Labels</strong> - Click any node name to edit both English and German</li>
                    <li><strong>Dual Language</strong> - Edit both English name and German translation</li>
                    <li><strong>Save Changes</strong> - Press Enter to move between fields or click away to save</li>
                    <li><strong>Auto-Save</strong> - Changes are automatically saved to browser cache</li>
                    <li><strong>Renamed Tracking</strong> - Edited English names are marked with ‚úèÔ∏è and "renamed" column set to TRUE</li>
                    <li><strong>German Change Tracking</strong> - Modified German translations are marked with "DE" and "german_changed" column set to TRUE</li>
                    <li><strong>Export CSV</strong> - Download your edited data as CSV with both renamed and German change flags</li>
                </ul>
                
                <h4>German Translation Features:</h4>
                <ul>
                    <li><strong>Side-by-Side Display</strong> - Shows "English | German" on the same row</li>
                    <li><strong>Optional Field</strong> - German translation is optional for each node</li>
                    <li><strong>Import/Export</strong> - Full support for German column in CSV files</li>
                    <li><strong>Inline Editing</strong> - Edit both languages simultaneously with side-by-side inputs</li>
                    <li><strong>Bilingual Search</strong> - Search works in both English and German text</li>
                </ul>
                
                <h4>Auto-Save Features:</h4>
                <ul>
                    <li><strong>Session Cache</strong> - All changes saved automatically to browser storage</li>
                    <li><strong>Visual Indicators</strong> - Green highlighting for renamed nodes</li>
                    <li><strong>Status Display</strong> - Auto-save indicator shows save status in toolbar</li>
                    <li><strong>Renamed Column</strong> - CSV export includes TRUE/FALSE for edited nodes</li>
                </ul>
                
                <h4>Duplicate Detection:</h4>
                <ul>
                    <li><strong>Find Duplicates</strong> - Click "üîç Find Duplicates" to scan for duplicate names</li>
                    <li><strong>Highlighting</strong> - Duplicate nodes are highlighted with yellow background</li>
                    <li><strong>Navigation Panel</strong> - Bottom-right panel shows all duplicates</li>
                    <li><strong>Click to Navigate</strong> - Click duplicate items to scroll to their location</li>
                </ul>
                
                <h4>Supported Formats:</h4>
                <ul>
                    <li>CSV files (.csv)</li>
                    <li>Excel files (.xlsx, .xls)</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        let nodesData = [];
        let flatNodesMap = new Map();
        let renderedNodes = new Set();
        let searchTerm = '';
        let loadingStartTime = Date.now();
        let totalNodes = 0;
        let editMode = false;
        let originalFileName = 'organigram_data';
        let duplicateDetectionActive = false;
        let duplicateGroups = new Map();
        
        // Auto-save and session management
        let sessionData = {
            originalData: null,
            modifiedNodes: new Map(),
            lastSaved: null,
            autoSaveEnabled: true
        };
        const AUTO_SAVE_DELAY = 1000; // 1 second after last change
        let autoSaveTimeout = null;

        // Auto-save and session management functions
        function initializeSession(data) {
            sessionData.originalData = JSON.parse(JSON.stringify(data));
            sessionData.modifiedNodes.clear();
            sessionData.lastSaved = Date.now();
            
            // Clear unsaved changes flag when initializing
            setUnsavedChanges(false);
            
            // Add 'renamed' and 'german_changed' properties to all nodes
            function addRenamedProperty(nodes) {
                nodes.forEach(node => {
                    if (!node.hasOwnProperty('renamed')) {
                        node.renamed = false;
                    }
                    if (!node.hasOwnProperty('german_changed')) {
                        node.german_changed = false;
                    }
                    if (!node.hasOwnProperty('german')) {
                        node.german = null;
                    }
                    if (node.children && node.children.length > 0) {
                        addRenamedProperty(node.children);
                    }
                });
            }
            
            addRenamedProperty(nodesData);
            saveSession();
            updatePerformanceInfo('Session initialized - Auto-save enabled');
        }
        
        function saveSession() {
            try {
                const sessionState = {
                    originalData: sessionData.originalData,
                    modifiedNodes: Array.from(sessionData.modifiedNodes.entries()),
                    lastSaved: Date.now(),
                    fileName: originalFileName,
                    timestamp: new Date().toISOString()
                };
                
                localStorage.setItem('organigram_session', JSON.stringify(sessionState));
                sessionData.lastSaved = Date.now();
                
                // Clear unsaved changes flag
                setUnsavedChanges(false);
                
                // Update UI indicator
                updateAutoSaveIndicator('saved');
            } catch (error) {
                console.error('Failed to save session:', error);
                updateAutoSaveIndicator('error');
            }
        }
        
        function loadSession() {
            try {
                const saved = localStorage.getItem('organigram_session');
                if (!saved) return false;
                
                const sessionState = JSON.parse(saved);
                sessionData.originalData = sessionState.originalData;
                sessionData.modifiedNodes = new Map(sessionState.modifiedNodes);
                sessionData.lastSaved = sessionState.lastSaved;
                
                if (sessionState.fileName) {
                    originalFileName = sessionState.fileName;
                }
                
                return true;
            } catch (error) {
                console.error('Failed to load session:', error);
                return false;
            }
        }
        
        function markNodeAsRenamed(nodeId, newName, oldName) {
            const node = flatNodesMap.get(nodeId);
            if (!node) return;
            
            // Update the node data
            node.name = newName;
            node.renamed = true;
            
            // Track the modification
            sessionData.modifiedNodes.set(nodeId, {
                originalName: oldName,
                newName: newName,
                timestamp: Date.now(),
                renamed: true
            });
            
            // Trigger auto-save
            scheduleAutoSave();
            
            // Update visual indicator
            updateNodeVisualState(nodeId);
        }
        
        function markGermanAsChanged(nodeId, newGerman, oldGerman) {
            const node = flatNodesMap.get(nodeId);
            if (!node) return;
            
            // Update the node data
            node.german = newGerman || null;
            node.german_changed = true;
            
            // Track the modification
            const existingModification = sessionData.modifiedNodes.get(nodeId) || {};
            sessionData.modifiedNodes.set(nodeId, {
                ...existingModification,
                originalGerman: oldGerman,
                newGerman: newGerman,
                timestamp: Date.now(),
                german_changed: true
            });
            
            // Trigger auto-save
            scheduleAutoSave();
            
            // Update visual indicator
            updateNodeVisualState(nodeId);
        }
        
        function scheduleAutoSave() {
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }
            
            // Mark as having unsaved changes
            setUnsavedChanges(true);
            updateAutoSaveIndicator('saving');
            
            autoSaveTimeout = setTimeout(() => {
                saveSession();
                setUnsavedChanges(false); // Clear unsaved flag after successful save
                updatePerformanceInfo(`Auto-saved ${sessionData.modifiedNodes.size} modifications`);
            }, AUTO_SAVE_DELAY);
        }
        
        function updateAutoSaveIndicator(status) {
            const indicator = document.getElementById('autoSaveIndicator');
            if (!indicator) return;
            
            const indicators = {
                'saving': 'üíæ Saving...',
                'saved': '‚úÖ Saved',
                'error': '‚ùå Save Error'
            };
            
            indicator.textContent = indicators[status] || '';
            indicator.className = `auto-save-indicator ${status}`;
        }
        
        function updateNodeVisualState(nodeId) {
            const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
            if (!nodeElement) return;
            
            const node = flatNodesMap.get(nodeId);
            const content = nodeElement.querySelector('.node-content');
            if (!content) return;
            
            // Handle renamed indicator
            if (node && node.renamed) {
                nodeElement.classList.add('node-renamed');
                
                // Add renamed indicator if not present
                if (!content.querySelector('.renamed-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'renamed-indicator';
                    indicator.textContent = '‚úèÔ∏è';
                    indicator.title = 'This node has been renamed';
                    content.appendChild(indicator);
                }
            }
            
            // Handle German changed indicator
            if (node && node.german_changed) {
                // Add German changed indicator if not present
                if (!content.querySelector('.german-changed-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'german-changed-indicator';
                    indicator.textContent = 'DE';
                    indicator.title = 'German translation has been modified';
                    content.appendChild(indicator);
                }
            }
        }
        
        function getModificationStats() {
            return {
                totalModifications: sessionData.modifiedNodes.size,
                lastSaved: sessionData.lastSaved,
                hasUnsavedChanges: autoSaveTimeout !== null
            };
        }
        
        function clearSession() {
            localStorage.removeItem('organigram_session');
            sessionData.originalData = null;
            sessionData.modifiedNodes.clear();
            sessionData.lastSaved = null;
            updatePerformanceInfo('Session cleared');
        }

        // File handling
        function showImportSection() {
            const importSection = document.getElementById('importSection');
            importSection.classList.remove('hidden');
            importSection.scrollIntoView({ behavior: 'smooth' });
        }

        function clearData() {
            nodesData = [];
            flatNodesMap.clear();
            renderedNodes.clear();
            totalNodes = 0;
            
            // Clear session data
            clearSession();
            
            document.getElementById('tree').innerHTML = '';
            document.getElementById('tree').style.display = 'none';
            document.getElementById('statsGrid').innerHTML = '';
            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';
            document.getElementById('performanceInfo').style.display = 'none';
            
            // Reset duplicate detection
            if (duplicateDetectionActive) {
                toggleDuplicateDetection();
            }
            
            // Reset edit mode
            if (editMode) {
                toggleEditMode();
            }
            
            showImportSection();
            updatePerformanceInfo('Data cleared - Please import a CSV file to get started');
            updateToolbarState(false); // Disable data-dependent buttons
        }

        function handleFileSelect(event) {
            console.log('File select event triggered');
            const file = event.target.files[0];
            if (file) {
                console.log('File selected:', file.name, 'Size:', file.size, 'Type:', file.type);
                processFile(file);
            } else {
                console.log('No file selected');
            }
        }

        function triggerFileInput() {
            console.log('Triggering file input click');
            document.getElementById('fileInput').click();
        }

        function processFile(file) {
            console.log('Processing file:', file.name);
            originalFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove extension
            const fileName = file.name;
            const fileExt = fileName.split('.').pop().toLowerCase();
            
            if (!['csv', 'xlsx', 'xls'].includes(fileExt)) {
                showError('Unsupported file format. Please use CSV or Excel files.');
                return;
            }

            showProgress(true);
            updateProgress(10, 'Reading file...');

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    console.log('File read successfully, size:', e.target.result.length);
                    if (fileExt === 'csv') {
                        processCSV(e.target.result);
                    } else {
                        showError('Excel files require server-side processing. Please convert to CSV format.');
                        showProgress(false);
                    }
                } catch (error) {
                    console.error('Error processing file:', error);
                    showError(`Error processing file: ${error.message}`);
                    showProgress(false);
                }
            };

            reader.onerror = function() {
                console.error('Error reading file');
                showError('Error reading file. Please try again.');
                showProgress(false);
            };

            reader.readAsText(file);
        }

        function processCSV(csvText) {
            try {
                updateProgress(30, 'Parsing CSV data...');
                
                const lines = csvText.split('\n').filter(line => line.trim());
                if (lines.length < 2) {
                    throw new Error('CSV file appears to be empty or invalid');
                }

                const headers = parseCSVLine(lines[0]);
                const requiredColumns = ['name', 'id', 'pid', 'level'];
                
                // Validate headers
                const missingColumns = requiredColumns.filter(col => !headers.includes(col));
                if (missingColumns.length > 0) {
                    throw new Error(`Missing required columns: ${missingColumns.join(', ')}`);
                }

                // Check if optional columns exist
                const hasRenamedColumn = headers.includes('renamed');
                const hasGermanColumn = headers.includes('name_de');
                const hasGermanChangedColumn = headers.includes('german_changed');

                updateProgress(50, 'Processing nodes...');

                const nodes = {};
                const childrenMap = new Map();

                for (let i = 1; i < lines.length; i++) {
                    const values = parseCSVLine(lines[i]);
                    if (values.length !== headers.length) continue;

                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index];
                    });

                    const nodeId = cleanField(row.id);
                    const pid = cleanField(row.pid);
                    const name = cleanField(row.name);
                    const level = cleanField(row.level);
                    const renamed = hasRenamedColumn ? 
                        (cleanField(row.renamed) === 'TRUE' || cleanField(row.renamed) === 'true') : 
                        false;
                    const german = hasGermanColumn ? cleanField(row.name_de) : null;
                    const germanChanged = hasGermanChangedColumn ? 
                        (cleanField(row.german_changed) === 'TRUE' || cleanField(row.german_changed) === 'true') : 
                        false;

                    if (!nodeId || !name) continue;

                    nodes[nodeId] = {
                        id: nodeId,
                        name: name,
                        pid: pid,
                        level: level || 'unknown',
                        renamed: renamed,
                        german: german,
                        german_changed: germanChanged,
                        children: []
                    };

                    if (pid) {
                        if (!childrenMap.has(pid)) {
                            childrenMap.set(pid, []);
                        }
                        childrenMap.get(pid).push(nodeId);
                    }
                }

                updateProgress(70, 'Building hierarchy...');

                // Add children to nodes
                for (const [parentId, childIds] of childrenMap) {
                    if (nodes[parentId]) {
                        nodes[parentId].children = childIds.map(id => nodes[id]).filter(Boolean);
                    }
                }

                updateProgress(90, 'Finalizing...');

                // Create hierarchy
                const hierarchy = Object.values(nodes)
                    .filter(node => !node.pid)
                    .map(rootNode => buildTree(rootNode, nodes));

                nodesData = hierarchy;
                buildFlatNodeMap(nodesData);
                
                // Initialize session for auto-save
                initializeSession(nodesData);
                
                updateProgress(100, 'Complete!');
                
                setTimeout(() => {
                    showProgress(false);
                    hideImportSection();
                    displayStats();
                    renderTree();
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('tree').style.display = 'block';
                    updatePerformanceInfo(`Successfully imported ${totalNodes.toLocaleString()} nodes`);
                    updateToolbarState(true); // Enable all buttons after successful import
                }, 1000);

            } catch (error) {
                showError(`Error processing CSV: ${error.message}`);
                showProgress(false);
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];
                
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        current += '"';
                        i++; // Skip next quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current);
            return result;
        }

        function cleanField(field) {
            if (!field || field === 'NULL' || field === '') {
                return null;
            }
            return String(field).trim().replace(/^["']|["']$/g, '');
        }

        function buildTree(node, allNodes) {
            const result = { ...node };
            result.children = node.children.map(child => buildTree(child, allNodes));
            return result;
        }

        function hideImportSection() {
            document.getElementById('importSection').classList.add('hidden');
        }

        function showProgress(show) {
            const progress = document.getElementById('importProgress');
            progress.style.display = show ? 'block' : 'none';
            if (!show) {
                updateProgress(0, '');
            }
        }

        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = `${percent}%`;
            document.getElementById('progressText').textContent = text;
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.innerHTML = `<h3>‚ö†Ô∏è Error</h3><p>${message}</p>`;
            errorDiv.style.display = 'block';
            document.getElementById('loading').style.display = 'none';
            document.getElementById('tree').style.display = 'none';
        }

        // Drag and drop
        const importSection = document.getElementById('importSection');
        
        importSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            importSection.classList.add('dragover');
        });

        importSection.addEventListener('dragleave', (e) => {
            e.preventDefault();
            importSection.classList.remove('dragover');
        });

        importSection.addEventListener('drop', (e) => {
            e.preventDefault();
            importSection.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        });

        // Modal functions
        function showHelpModal() {
            document.getElementById('helpModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('helpModal').style.display = 'none';
        }

        function downloadSample() {
            const sampleCSV = `name,id,pid,level,renamed,name_de,german_changed
"Company","1",,"l1","FALSE","Unternehmen","FALSE"
"Engineering","2","1","l2","FALSE","Entwicklung","FALSE"
"Product","3","1","l2","FALSE","Produkt","FALSE"
"Frontend Team","4","2","l3","FALSE","Frontend-Team","FALSE"
"Backend Team","5","2","l3","FALSE","Backend-Team","FALSE"
"Design Team","6","3","l3","FALSE","Design-Team","FALSE"
"John Doe","7","4","l4","FALSE","Hans M√ºller","FALSE"
"Jane Smith","8","4","l4","FALSE","Jana Schmidt","FALSE"
"Bob Wilson","9","5","l4","FALSE","Robert Weber","FALSE"
"Alice Johnson","10","6","l4","FALSE","Alicia Jung","FALSE"`;

            const blob = new Blob([sampleCSV], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sample_organigram.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        // Edit Mode Functions
        function toggleEditMode() {
            if (nodesData.length === 0) {
                alert('No data loaded. Please import a CSV file first.');
                return;
            }
            
            editMode = !editMode;
            const button = event.target;
            const treeContainer = document.getElementById('tree');
            
            if (editMode) {
                button.textContent = '‚úÖ Save Mode';
                button.classList.add('primary');
                treeContainer.classList.add('edit-mode');
                updatePerformanceInfo('Edit mode enabled - Click on any label to edit');
            } else {
                button.textContent = '‚úèÔ∏è Edit Mode';
                button.classList.remove('primary');
                treeContainer.classList.remove('edit-mode');
                updatePerformanceInfo('Edit mode disabled');
            }
        }

        function makeNodeEditable(nodeElement, node) {
            if (!editMode) return;
            
            const label = nodeElement.querySelector('.node-label');
            if (label.querySelector('input')) return; // Already editing
            
            const currentText = node.name;
            const currentGerman = node.german || '';
            
            // Create editing interface with side-by-side inputs
            label.innerHTML = `
                <div style="display: flex; align-items: center; gap: 6px; width: 100%;">
                    <input type="text" value="${currentText}" placeholder="English name" 
                           onblur="saveNodeEdit(this, '${node.id}', 'name')" 
                           onkeypress="handleEditKeypress(event, this, '${node.id}', 'name')"
                           style="font-weight: 500; font-size: 13px; flex: 1; min-width: 120px; border: 1px solid #ccc; padding: 2px 4px; border-radius: 2px;">
                    <span style="color: #999; font-size: 12px;">|</span>
                    <input type="text" value="${currentGerman}" placeholder="German (optional)" 
                           onblur="saveNodeEdit(this, '${node.id}', 'german')" 
                           onkeypress="handleEditKeypress(event, this, '${node.id}', 'german')"
                           style="font-size: 12px; color: #666; font-style: italic; flex: 1; min-width: 120px; border: 1px solid #ccc; padding: 2px 4px; border-radius: 2px;">
                </div>
            `;
            
            const firstInput = label.querySelector('input');
            firstInput.focus();
            firstInput.select();
        }

        function saveNodeEdit(input, nodeId, fieldType) {
            const newValue = input.value.trim();
            
            // Get the current node data
            const node = flatNodesMap.get(nodeId);
            if (!node) return;
            
            if (fieldType === 'name') {
                if (newValue === '') {
                    input.focus();
                    return;
                }
                
                const oldName = node.name;
                
                // Only mark as renamed if the name actually changed
                if (oldName !== newValue) {
                    markNodeAsRenamed(nodeId, newValue, oldName);
                    updatePerformanceInfo(`Updated node: ${nodeId} -> "${newValue}" (Auto-saved)`);
                } else {
                    node.name = newValue;
                }
            } else if (fieldType === 'german') {
                // German translation can be empty
                const oldGerman = node.german || '';
                if (oldGerman !== newValue) {
                    markGermanAsChanged(nodeId, newValue, oldGerman);
                    updatePerformanceInfo(`Updated German translation for node: ${nodeId} (Auto-saved)`);
                }
            }
            
            // Don't restore display immediately - let user continue editing
            // Only restore when they click outside the entire editing area
            // Use a timeout to check if focus moved to another input in the same node
            setTimeout(() => {
                const label = input.closest('.node-label');
                const activeElement = document.activeElement;
                const isStillEditingThisNode = label && label.contains(activeElement) && activeElement.tagName === 'INPUT';
                
                if (!isStillEditingThisNode) {
                    // Check if English field is empty (required field)
                    const englishInput = label.querySelector('input[placeholder*="English"]');
                    if (englishInput && englishInput.value.trim() === '') {
                        englishInput.focus();
                        return;
                    }
                    
                    // Restore the display
                    restoreNodeDisplay(nodeId);
                }
            }, 50);
        }
        
        function restoreNodeDisplay(nodeId) {
            const node = flatNodesMap.get(nodeId);
            if (!node) return;
            
            const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
            const label = nodeElement.querySelector('.node-label');
            
            // Clear the editing interface
            label.innerHTML = '';
            
            // Create main name element
            const mainName = document.createElement('span');
            mainName.className = 'node-label-main';
            mainName.textContent = node.name;
            label.appendChild(mainName);
            
            // Add German translation if available
            if (node.german && node.german.trim()) {
                const separator = document.createElement('span');
                separator.className = 'node-label-separator';
                separator.textContent = '|';
                label.appendChild(separator);
                
                const germanName = document.createElement('span');
                germanName.className = 'node-label-german';
                germanName.textContent = node.german;
                label.appendChild(germanName);
            }
        }

        function handleEditKeypress(event, input, nodeId, fieldType) {
            if (event.key === 'Enter') {
                if (fieldType === 'name') {
                    // Move to German field if available
                    const germanInput = input.parentElement.querySelector('input[placeholder*="German"]');
                    if (germanInput) {
                        germanInput.focus();
                    } else {
                        input.blur();
                    }
                } else {
                    input.blur();
                }
            } else if (event.key === 'Escape') {
                // Restore original values
                restoreNodeDisplay(nodeId);
            }
        }

        // Export Functions
        function exportToCSV() {
            if (nodesData.length === 0) {
                alert('No data to export. Please import a CSV file first.');
                return;
            }
            
            const csvContent = generateCSVFromNodes();
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = window.URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${originalFileName}_edited.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            updatePerformanceInfo(`Exported ${totalNodes} nodes to CSV`);
        }

        function generateCSVFromNodes() {
            const rows = ['name,id,pid,level,renamed,name_de,german_changed'];
            
            function addNodeToCSV(node) {
                const name = `"${node.name.replace(/"/g, '""')}"`;
                const id = `"${node.id}"`;
                const pid = node.pid ? `"${node.pid}"` : '';
                const level = `"${node.level}"`;
                const renamed = node.renamed ? 'TRUE' : 'FALSE';
                const german = node.german ? `"${node.german.replace(/"/g, '""')}"` : '';
                const germanChanged = node.german_changed ? 'TRUE' : 'FALSE';
                
                rows.push(`${name},${id},${pid},${level},${renamed},${german},${germanChanged}`);
                
                if (node.children && node.children.length > 0) {
                    node.children.forEach(child => addNodeToCSV(child));
                }
            }
            
            nodesData.forEach(rootNode => addNodeToCSV(rootNode));
            return rows.join('\n');
        }

        // Duplicate Detection Functions
        function toggleDuplicateDetection() {
            if (nodesData.length === 0) {
                alert('No data loaded. Please import a CSV file first.');
                return;
            }
            
            duplicateDetectionActive = !duplicateDetectionActive;
            const button = event.target;
            
            if (duplicateDetectionActive) {
                button.textContent = '‚úÖ Hide Duplicates';
                button.classList.add('primary');
                findAndHighlightDuplicates();
                showDuplicatePanel();
                updatePerformanceInfo('Duplicate detection enabled');
            } else {
                button.textContent = 'üîç Find Duplicates';
                button.classList.remove('primary');
                clearDuplicateHighlights();
                closeDuplicatePanel();
                updatePerformanceInfo('Duplicate detection disabled');
            }
        }

        function findAndHighlightDuplicates() {
            duplicateGroups.clear();
            
            // Group nodes by parent and name
            const parentGroups = new Map();
            
            flatNodesMap.forEach((node, nodeId) => {
                const parentId = node.pid || 'ROOT';
                const nodeName = node.name.toLowerCase().trim();
                
                if (!parentGroups.has(parentId)) {
                    parentGroups.set(parentId, new Map());
                }
                
                const parentGroup = parentGroups.get(parentId);
                if (!parentGroup.has(nodeName)) {
                    parentGroup.set(nodeName, []);
                }
                
                parentGroup.get(nodeName).push(node);
            });
            
            // Find duplicates within each parent group
            parentGroups.forEach((nameGroups, parentId) => {
                nameGroups.forEach((nodes, nodeName) => {
                    if (nodes.length > 1) {
                        const parentNode = flatNodesMap.get(parentId) || { name: 'Root Level' };
                        const groupKey = `${parentId}_${nodeName}`;
                        duplicateGroups.set(groupKey, {
                            parentName: parentNode.name,
                            nodeName: nodes[0].name, // Original case
                            nodes: nodes
                        });
                    }
                });
            });
            
            // Highlight duplicate nodes
            duplicateGroups.forEach(group => {
                group.nodes.forEach(node => {
                    const nodeElement = document.querySelector(`[data-id="${node.id}"] .node-content`);
                    if (nodeElement) {
                        nodeElement.classList.add('node-duplicate');
                    }
                });
            });
            
            updateDuplicatePanel();
        }

        function clearDuplicateHighlights() {
            document.querySelectorAll('.node-duplicate').forEach(element => {
                element.classList.remove('node-duplicate');
            });
            duplicateGroups.clear();
        }

        function showDuplicatePanel() {
            document.getElementById('duplicatePanel').style.display = 'block';
        }

        function closeDuplicatePanel() {
            document.getElementById('duplicatePanel').style.display = 'none';
        }

        function updateDuplicatePanel() {
            const content = document.getElementById('duplicateContent');
            
            if (duplicateGroups.size === 0) {
                content.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No duplicates found within the same categories.</div>';
                return;
            }
            
            let html = '';
            
            duplicateGroups.forEach((group, groupKey) => {
                html += `
                    <div class="duplicate-group">
                        <div class="duplicate-group-header">
                            "${group.nodeName}" in ${group.parentName} (${group.nodes.length} copies)
                        </div>
                `;
                
                group.nodes.forEach((node, index) => {
                    const path = getNodePath(node);
                    html += `
                        <div class="duplicate-item" onclick="scrollToNode('${node.id}')">
                            <div class="duplicate-item-name">${node.name} (ID: ${node.id})</div>
                            <div class="duplicate-item-path">${path}</div>
                        </div>
                    `;
                });
                
                html += '</div>';
            });
            
            content.innerHTML = html;
        }

        function getNodePath(node) {
            const path = [];
            let current = node;
            
            while (current && current.pid) {
                const parent = flatNodesMap.get(current.pid);
                if (parent) {
                    path.unshift(parent.name);
                    current = parent;
                } else {
                    break;
                }
            }
            
            return path.length > 0 ? path.join(' > ') : 'Root Level';
        }

        function scrollToNode(nodeId) {
            // First expand the path to the node
            expandPathToNode(nodeId);
            
            // Wait a bit for the expansion to complete, then scroll
            setTimeout(() => {
                const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
                if (nodeElement) {
                    // Temporarily highlight the target node
                    const nodeContent = nodeElement.querySelector('.node-content');
                    nodeContent.style.transition = 'all 0.3s ease';
                    nodeContent.style.backgroundColor = '#007bff';
                    nodeContent.style.color = 'white';
                    nodeContent.style.transform = 'scale(1.02)';
                    
                    // Scroll to the node
                    nodeElement.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                    
                    // Remove highlight after a delay
                    setTimeout(() => {
                        nodeContent.style.backgroundColor = '';
                        nodeContent.style.color = '';
                        nodeContent.style.transform = '';
                        
                        // Restore duplicate highlighting if it was there
                        if (duplicateDetectionActive) {
                            setTimeout(() => {
                                nodeContent.classList.add('node-duplicate');
                            }, 300);
                        }
                    }, 1500);
                    
                    updatePerformanceInfo(`Navigated to node: ${nodeId}`);
                }
            }, 200);
        }

        window.onclick = function(event) {
            const modal = document.getElementById('helpModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }

        // Performance monitoring
        function updatePerformanceInfo(message) {
            const perfInfo = document.getElementById('performanceInfo');
            const elapsed = Date.now() - loadingStartTime;
            perfInfo.innerHTML = `
                <strong>Status:</strong> ${message} | 
                <strong>Load Time:</strong> ${elapsed}ms | 
                <strong>Memory:</strong> ${(performance.memory?.usedJSHeapSize / 1024 / 1024).toFixed(1) || 'N/A'} MB
            `;
            perfInfo.style.display = 'block';
        }

        // Build flat map for efficient lookups
        function buildFlatNodeMap(nodes) {
            function processNode(node) {
                flatNodesMap.set(node.id, node);
                totalNodes++;
                if (node.children && node.children.length > 0) {
                    node.children.forEach(child => processNode(child));
                }
            }
            
            totalNodes = 0;
            flatNodesMap.clear();
            nodes.forEach(rootNode => processNode(rootNode));
        }

        // Display statistics
        function displayStats() {
            const stats = calculateStats(nodesData);
            document.getElementById('statsGrid').innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${totalNodes.toLocaleString()}</div>
                    <div>Total Nodes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.rootNodes}</div>
                    <div>Root Categories</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.levels.l1 || 0}</div>
                    <div>Level 1</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.levels.l2 || 0}</div>
                    <div>Level 2</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.levels.l3 || 0}</div>
                    <div>Level 3</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.levels.l4 || 0}</div>
                    <div>Level 4</div>
                </div>
            `;
        }

        function calculateStats(data) {
            const levels = {};
            
            flatNodesMap.forEach(node => {
                levels[node.level] = (levels[node.level] || 0) + 1;
            });

            return {
                totalNodes: totalNodes,
                rootNodes: data.length,
                levels: levels
            };
        }

        // Render tree with lazy loading
        function renderTree() {
            const treeElement = document.getElementById('tree');
            treeElement.innerHTML = '';
            renderedNodes.clear();
            
            nodesData.forEach(rootNode => {
                treeElement.appendChild(createNodeElement(rootNode, false));
            });
            
            // Re-apply duplicate detection if it was active
            if (duplicateDetectionActive) {
                setTimeout(() => {
                    findAndHighlightDuplicates();
                }, 100);
            }
            
            updatePerformanceInfo(`Rendered ${nodesData.length} root nodes`);
        }

        function createNodeElement(node, isExpanded = false) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = `node level-${node.level}`;
            nodeDiv.setAttribute('data-id', node.id);
            
            const hasChildren = node.children && node.children.length > 0;
            
            const nodeContent = document.createElement('div');
            nodeContent.className = 'node-content';
            nodeContent.onclick = () => toggleNode(node.id);
            
            const toggleBtn = document.createElement('button');
            toggleBtn.className = `toggle-btn ${hasChildren ? '' : 'no-children'}`;
            toggleBtn.innerHTML = hasChildren ? (isExpanded ? '‚àí' : '+') : '‚óè';
            
            const label = document.createElement('span');
            label.className = 'node-label editable';
            
            // Create main name element
            const mainName = document.createElement('span');
            mainName.className = 'node-label-main';
            mainName.textContent = node.name;
            label.appendChild(mainName);
            
            // Add German translation if available
            if (node.german && node.german.trim()) {
                const separator = document.createElement('span');
                separator.className = 'node-label-separator';
                separator.textContent = '|';
                label.appendChild(separator);
                
                const germanName = document.createElement('span');
                germanName.className = 'node-label-german';
                germanName.textContent = node.german;
                label.appendChild(germanName);
            }
            
            label.onclick = (e) => {
                e.stopPropagation();
                makeNodeEditable(nodeDiv, node);
            };
            
            const editIndicator = document.createElement('span');
            editIndicator.className = 'edit-indicator';
            editIndicator.textContent = '‚úèÔ∏è';
            
            const info = document.createElement('span');
            info.className = 'node-info';
            info.textContent = `${node.level} | ID: ${node.id}`;
            if (hasChildren) {
                info.textContent += ` | ${node.children.length} children`;
            }
            
            nodeContent.appendChild(toggleBtn);
            nodeContent.appendChild(label);
            nodeContent.appendChild(editIndicator);
            
            // Add renamed indicator if node was renamed
            if (node.renamed) {
                const renamedIndicator = document.createElement('span');
                renamedIndicator.className = 'renamed-indicator';
                renamedIndicator.textContent = '‚úèÔ∏è';
                renamedIndicator.title = 'This node has been renamed';
                nodeContent.appendChild(renamedIndicator);
                nodeDiv.classList.add('node-renamed');
            }
            
            // Add German changed indicator if German translation was modified
            if (node.german_changed) {
                const germanChangedIndicator = document.createElement('span');
                germanChangedIndicator.className = 'german-changed-indicator';
                germanChangedIndicator.textContent = 'DE';
                germanChangedIndicator.title = 'German translation has been modified';
                nodeContent.appendChild(germanChangedIndicator);
            }
            
            nodeContent.appendChild(info);
            nodeDiv.appendChild(nodeContent);
            
            if (hasChildren && isExpanded) {
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'children expanded';
                
                node.children.forEach(child => {
                    childrenDiv.appendChild(createNodeElement(child, false));
                });
                
                nodeDiv.appendChild(childrenDiv);
            } else if (hasChildren) {
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'children collapsed';
                nodeDiv.appendChild(childrenDiv);
            }
            
            renderedNodes.add(node.id);
            return nodeDiv;
        }

        function toggleNode(nodeId) {
            const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
            if (!nodeElement) return;
            
            const node = flatNodesMap.get(nodeId);
            if (!node || !node.children || node.children.length === 0) return;
            
            const childrenDiv = nodeElement.querySelector('.children');
            const toggleBtn = nodeElement.querySelector('.toggle-btn');
            const isExpanded = childrenDiv.classList.contains('expanded');
            
            if (isExpanded) {
                childrenDiv.classList.remove('expanded');
                childrenDiv.classList.add('collapsed');
                toggleBtn.innerHTML = '+';
            } else {
                if (childrenDiv.children.length === 0) {
                    node.children.forEach(child => {
                        childrenDiv.appendChild(createNodeElement(child, false));
                    });
                }
                
                childrenDiv.classList.remove('collapsed');
                childrenDiv.classList.add('expanded');
                toggleBtn.innerHTML = '‚àí';
            }
        }

        function expandLevel(maxLevel) {
            collapseAll();
            
            document.querySelectorAll('.node').forEach(nodeElement => {
                const nodeId = nodeElement.getAttribute('data-id');
                const node = flatNodesMap.get(nodeId);
                if (node) {
                    const level = parseInt(node.level.substring(1));
                    if (level < maxLevel && node.children && node.children.length > 0) {
                        toggleNode(nodeId);
                    }
                }
            });
            
            updatePerformanceInfo(`Expanded to level ${maxLevel}`);
        }

        function collapseAll() {
            document.querySelectorAll('.children.expanded').forEach(childrenDiv => {
                const nodeElement = childrenDiv.closest('.node');
                const nodeId = nodeElement.getAttribute('data-id');
                const toggleBtn = nodeElement.querySelector('.toggle-btn');
                
                childrenDiv.classList.remove('expanded');
                childrenDiv.classList.add('collapsed');
                toggleBtn.innerHTML = '+';
            });
            
            updatePerformanceInfo('Collapsed all nodes');
        }

        function searchNodes() {
            const searchInput = document.getElementById('searchInput');
            searchTerm = searchInput.value.toLowerCase().trim();
            
            // Clear previous search results and arrows
            document.querySelectorAll('.node-content.highlighted').forEach(element => {
                element.classList.remove('highlighted');
            });
            clearSearchArrows();
            
            if (searchTerm === '') return;
            
            let matchCount = 0;
            const startTime = Date.now();
            const matchingNodes = [];
            
            flatNodesMap.forEach((node, nodeId) => {
                const englishMatch = node.name.toLowerCase().includes(searchTerm);
                const germanMatch = node.german && node.german.toLowerCase().includes(searchTerm);
                
                if (englishMatch || germanMatch) {
                    matchCount++;
                    expandPathToNode(nodeId);
                    
                    const nodeElement = document.querySelector(`[data-id="${nodeId}"] .node-content`);
                    if (nodeElement) {
                        nodeElement.classList.add('highlighted');
                        matchingNodes.push(nodeElement);
                    }
                }
            });
            
            const searchTime = Date.now() - startTime;
            updatePerformanceInfo(`Found ${matchCount} matches in ${searchTime}ms`);
            
            // Add arrow indicators for all matching nodes
            setTimeout(() => {
                addSearchArrows(matchingNodes);
                
                const firstMatch = document.querySelector('.node-content.highlighted');
                if (firstMatch) {
                    firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }

        function expandPathToNode(nodeId) {
            const path = [];
            let currentNode = flatNodesMap.get(nodeId);
            
            while (currentNode && currentNode.pid) {
                path.unshift(currentNode.pid);
                currentNode = flatNodesMap.get(currentNode.pid);
            }
            
            path.forEach(id => {
                const nodeElement = document.querySelector(`[data-id="${id}"]`);
                if (nodeElement) {
                    const childrenDiv = nodeElement.querySelector('.children');
                    if (childrenDiv && childrenDiv.classList.contains('collapsed')) {
                        toggleNode(id);
                    }
                }
            });
        }

        function addSearchArrows(matchingNodes) {
            clearSearchArrows(); // Clear any existing arrows first
            
            matchingNodes.forEach((nodeElement, index) => {
                const rect = nodeElement.getBoundingClientRect();
                const arrow = document.createElement('div');
                arrow.className = 'search-arrow';
                arrow.style.top = (rect.top + rect.height / 2 - 12) + 'px'; // Center arrow with node
                arrow.setAttribute('data-node-id', nodeElement.closest('[data-id]').getAttribute('data-id'));
                
                // Add a slight delay for each arrow to create a staggered animation effect
                arrow.style.animationDelay = (index * 0.2) + 's';
                
                document.body.appendChild(arrow);
            });
            
            // Update arrow positions on scroll
            updateArrowPositions();
        }

        function updateArrowPositions() {
            const arrows = document.querySelectorAll('.search-arrow');
            arrows.forEach(arrow => {
                const nodeId = arrow.getAttribute('data-node-id');
                const nodeElement = document.querySelector(`[data-id="${nodeId}"] .node-content`);
                if (nodeElement) {
                    const rect = nodeElement.getBoundingClientRect();
                    // Only show arrow if node is visible on screen
                    if (rect.top >= 0 && rect.bottom <= window.innerHeight) {
                        arrow.style.top = (rect.top + rect.height / 2 - 12) + 'px';
                        arrow.style.display = 'block';
                    } else {
                        arrow.style.display = 'none'; // Hide arrows for off-screen nodes
                    }
                }
            });
        }

        function clearSearchArrows() {
            document.querySelectorAll('.search-arrow').forEach(arrow => {
                arrow.remove();
            });
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            searchTerm = '';
            document.querySelectorAll('.node-content.highlighted').forEach(element => {
                element.classList.remove('highlighted');
            });
            clearSearchArrows(); // Clear arrows when clearing search
            updatePerformanceInfo('Search cleared');
        }

        // Try to load default data on startup
        document.addEventListener('DOMContentLoaded', async function() {
            // Don't load default data - force user to import CSV
            console.log('Interactive Organigram loaded - please import a CSV file to begin');
            updatePerformanceInfo('Ready - Please import a CSV file to get started');
            updateToolbarState(false); // Disable data-dependent buttons
        });

        // Update toolbar button states based on whether data is loaded
        function updateToolbarState(hasData) {
            const buttons = ['clearBtn', 'exportBtn', 'editBtn', 'duplicateBtn', 'expandL1', 'expandL2', 'collapseBtn', 'clearSearchBtn'];
            const searchInput = document.getElementById('searchInput');
            
            buttons.forEach(buttonId => {
                const button = document.getElementById(buttonId);
                if (button) {
                    button.disabled = !hasData;
                }
            });
            
            if (searchInput) {
                searchInput.disabled = !hasData;
                if (!hasData) {
                    searchInput.value = '';
                    searchInput.placeholder = 'Import data to enable search...';
                } else {
                    searchInput.placeholder = 'Search nodes (English/German) - Press Enter to search...';
                }
            }
        }

        // Search functionality
        function handleSearchKeypress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                searchNodes();
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey || event.metaKey) {
                switch(event.key) {
                    case 'f':
                        event.preventDefault();
                        document.getElementById('searchInput').focus();
                        break;
                    case 'c':
                        event.preventDefault();
                        collapseAll();
                        break;
                }
            }
            if (event.key === 'Escape') {
                clearSearch();
                closeConfirmationModal();
            }
        });

        // Confirmation Modal System
        let confirmationCallback = null;
        let hasUnsavedChanges = false;

        function showConfirmationModal(title, message, onConfirm) {
            const modal = document.getElementById('confirmationModal');
            const titleElement = document.getElementById('confirmationTitle');
            const messageElement = document.getElementById('confirmationMessage');
            
            titleElement.textContent = title;
            messageElement.textContent = message;
            confirmationCallback = onConfirm;
            
            modal.style.display = 'flex';
        }

        function closeConfirmationModal() {
            const modal = document.getElementById('confirmationModal');
            modal.style.display = 'none';
            confirmationCallback = null;
        }

        function confirmAction() {
            if (confirmationCallback) {
                confirmationCallback();
            }
            closeConfirmationModal();
        }

        // Track unsaved changes
        function setUnsavedChanges(hasChanges) {
            hasUnsavedChanges = hasChanges;
        }

        // Enhanced clear data function with confirmation
        function clearDataWithConfirmation() {
            if (nodesData.length === 0) {
                alert('No data to clear.');
                return;
            }

            const modificationStats = getModificationStats();
            let message = 'This will permanently delete all loaded data and clear the organigram.';
            
            if (modificationStats.totalModifications > 0) {
                message += `\n\nYou have ${modificationStats.totalModifications} unsaved modification(s) that will be lost.`;
            }
            
            message += '\n\nThis action cannot be undone. Are you sure?';

            showConfirmationModal(
                'Clear All Data',
                message,
                function() {
                    // Clear session data and refresh the page for a fresh start
                    clearSession();
                    localStorage.removeItem('organigram_session');
                    
                    // Refresh the page to start completely fresh
                    window.location.reload();
                }
            );
        }

        // Page unload warning
        window.addEventListener('beforeunload', function(event) {
            if (hasUnsavedChanges || (sessionData.modifiedNodes && sessionData.modifiedNodes.size > 0)) {
                const message = 'You have unsaved changes. Are you sure you want to leave?';
                event.preventDefault();
                event.returnValue = message;
                return message;
            }
        });

        // Update search arrow positions on scroll
        let scrollTimeout;
        window.addEventListener('scroll', function() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(updateArrowPositions, 16); // Throttle to ~60fps
        });

        // Modal event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const confirmBtn = document.getElementById('confirmationConfirm');
            const cancelBtn = document.getElementById('confirmationCancel');
            const modal = document.getElementById('confirmationModal');

            if (confirmBtn) {
                confirmBtn.addEventListener('click', confirmAction);
            }

            if (cancelBtn) {
                cancelBtn.addEventListener('click', closeConfirmationModal);
            }

            // Close modal when clicking outside
            if (modal) {
                modal.addEventListener('click', function(event) {
                    if (event.target === modal) {
                        closeConfirmationModal();
                    }
                });
            }
        });
    </script>

    <!-- Floating Help Button -->
    <button class="floating-help" onclick="showHelpModal()" title="Help & Documentation">
        ‚ùì
    </button>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="confirmation-modal">
        <div class="confirmation-content">
            <div class="confirmation-title">
                <span>‚ö†Ô∏è</span>
                <span id="confirmationTitle">Confirm Action</span>
            </div>
            <div id="confirmationMessage" class="confirmation-message">
                Are you sure you want to proceed?
            </div>
            <div class="confirmation-buttons">
                <button id="confirmationCancel" class="confirmation-btn secondary">Cancel</button>
                <button id="confirmationConfirm" class="confirmation-btn danger">Confirm</button>
            </div>
        </div>
    </div>
</body>
</html>
